<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Nix Types - a first step in the right direction</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/highlight-dark.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="goals.html"><strong aria-hidden="true">1.1.</strong> Goal / Scope</a></li><li class="chapter-item expanded "><a href="problems.html"><strong aria-hidden="true">1.2.</strong> Inconsistencies</a></li><li class="chapter-item expanded "><a href="impact.html"><strong aria-hidden="true">1.3.</strong> Impact</a></li></ol></li><li class="chapter-item expanded "><a href="examples.html"><strong aria-hidden="true">2.</strong> Examples</a></li><li class="chapter-item expanded "><a href="specification/formals.html"><strong aria-hidden="true">3.</strong> Formals</a></li><li class="chapter-item expanded "><a href="specification/types.html"><strong aria-hidden="true">4.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="specification/basic.html"><strong aria-hidden="true">4.1.</strong> Primitives</a></li><li class="chapter-item expanded "><a href="specification/complex.html"><strong aria-hidden="true">4.2.</strong> Complex</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="specification/list.html"><strong aria-hidden="true">4.2.1.</strong> List</a></li><li class="chapter-item expanded "><a href="specification/attrset.html"><strong aria-hidden="true">4.2.2.</strong> AttrSet</a></li><li class="chapter-item expanded "><a href="specification/lambda.html"><strong aria-hidden="true">4.2.3.</strong> Lambda</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="specification/operators.html"><strong aria-hidden="true">5.</strong> Operators</a></li><li class="chapter-item expanded "><a href="specification/type-variables.html"><strong aria-hidden="true">6.</strong> Type Variables</a></li><li class="chapter-item expanded "><a href="nix/index.html"><strong aria-hidden="true">7.</strong> Nix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="nix/operations.html"><strong aria-hidden="true">7.1.</strong> Operations</a></li><li class="chapter-item expanded "><a href="nix/builtins.html"><strong aria-hidden="true">7.2.</strong> Builtins</a></li></ol></li><li class="chapter-item expanded "><a href="specification/usage.html"><strong aria-hidden="true">8.</strong> Usage</a></li><li class="chapter-item expanded "><a href="contributors.html"><strong aria-hidden="true">9.</strong> Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Nix Types - a first step in the right direction</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>ðŸš§ðŸš§ðŸš§ RFC Under construction ðŸš§ðŸš§ðŸš§ðŸš§</p>
<p>This Draft of an RFC could be the first step to improve how nix is used as a language.</p>
<p>Generally there are two type systems:</p>
<ul>
<li>
<p><strong>Static</strong>
checked during 'compile' time or development time.
So errors can be caught while writing code.</p>
<p><strong>Does not exist in nix</strong></p>
</li>
<li>
<p><strong>Dynamic</strong></p>
<ul>
<li>Fails execution of code based on conditionals.</li>
<li>Used in <code>lib/types.nix</code></li>
<li>Used in <code>YANTS</code></li>
</ul>
</li>
</ul>
<h2 id="proposal-type-hints"><a class="header" href="#proposal-type-hints">Proposal: Type hints</a></h2>
<p>I propose to build a set of simple yet effective <code>type hints</code>, which would mimic <code>static types</code> instead of investing to much into the dynamic types approach,
or trying to bring static types into the dynamic nix language.</p>
<p>By using <code>type hints</code> many additional possibilities even for dynamically typed languages arise.</p>
<ul>
<li>determine whether a program would actually work or not, just by looking at the types.</li>
<li>provide autocompletion on typed variable- and function-bindings.</li>
<li>automatically generate good documentation directly from code.</li>
<li>...</li>
</ul>
<h2 id="dynamic-type-validations-are-still-needed"><a class="header" href="#dynamic-type-validations-are-still-needed">Dynamic type validations are still needed</a></h2>
<p>As type hints cannot provide any runtime assurances it is still needed to place guards in critical places.
But instead of trying to represent a non-existent static type system;
The dynamic approach should transparently communicate what it really does: &quot;Runtime validation&quot;.</p>
<h2 id="analogy-to-other-dynamic-languages"><a class="header" href="#analogy-to-other-dynamic-languages">Analogy to other dynamic languages</a></h2>
<p><img src="./assets/Other-dynamic-languages.drawio.png" alt="other-dynamic-languages" /></p>
<h2 id="vision"><a class="header" href="#vision">Vision</a></h2>
<p>This project can be seen as a first step of possibly many.</p>
<p>There are many opinions about whether static types make sense at all in nix.</p>
<p>But this project does not discuss those. Instead i propose that &quot;types&quot; in whatever form do make total sense. And will give much value to dynamic languages.
Which can undoubtedly be seen on the above examples (Python, Javascript).</p>
<p><strong>Discussion about</strong>
<code>Does typing make sense in a dynamic Language</code>
<strong>is open, but history has a clear answer to that.</strong></p>
<p>By specifying the comments and not directly integrating types
into the nix language this project stays downwards compatible
and allows an intermediate phase of transition and validation.</p>
<p>In that validation phase the system can obtain feedback and corrections.</p>
<p>It could then be made so good, that it really represents nix's type behavior.</p>
<blockquote>
<p>NOTE: Currently out of scope of this project.
Change the nix language to natively support type annotations. (Even if they are not real static types)
<code>Types</code> could then be built from the findings of this project.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="goal--scope"><a class="header" href="#goal--scope">Goal / Scope</a></h1>
<p><strong>Disclaimer: While <code>types</code> are great. This doesn't introduce any types into nix.</strong></p>
<h2 id="the-goal--scope"><a class="header" href="#the-goal--scope">The Goal / Scope</a></h2>
<h3 id="introduce-a-type-annotation-system-for-the-doc-strings"><a class="header" href="#introduce-a-type-annotation-system-for-the-doc-strings">Introduce a type annotation system for the doc-strings</a></h3>
<p>Which can be seen as the first step towards static types.</p>
<h3 id="enhance-the-system-so-it-is-possible-to-annotate-the-type-of-everything-in-nix"><a class="header" href="#enhance-the-system-so-it-is-possible-to-annotate-the-type-of-everything-in-nix">Enhance the system so it is possible to annotate the type of everything in nix</a></h3>
<ul>
<li>Write down <em>convention</em> of the current typing system in nix. (<code>Type:</code> doc-stings)</li>
<li>Let the convention be so, that we can parse the <code>Type:</code> into an useful <code>AST</code> (Abstract Syntax Tree).</li>
<li>Provide a type-system that could proof correctness of code before runtime.</li>
<li>Provide a Parser and AST Specification for that type system.</li>
</ul>
<p>Currently there is the <code>type:</code> pattern which can be parsed from nixdoc. Which is a good start but not enough.
The goal is to build more accurate type comments and have a consistent convention on what is actually allowed and what is not.</p>
<p>Although nix doesn't have a type system, it has types. (See <a href="https://nixos.org/manual/nix/stable/language/values.html">here</a>)</p>
<p>Because there are different ways for developers to express typings they are very inconsistent</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inconsistencies"><a class="header" href="#inconsistencies">Inconsistencies</a></h1>
<p>When ready through <strong>nixpkgs</strong> there are many comments that document functions and variables like this:</p>
<pre><code class="language-nix">  /* Construct a Unix-style, colon-separated search path consisting of
     the given `subDir` appended to each of the given paths.
     Type: makeSearchPath :: string -&gt; [string] -&gt; string
     Example:
       makeSearchPath &quot;bin&quot; [&quot;/root&quot; &quot;/usr&quot; &quot;/usr/local&quot;]
       =&gt; &quot;/root/bin:/usr/bin:/usr/local/bin&quot;
       makeSearchPath &quot;bin&quot; [&quot;&quot;]
       =&gt; &quot;/bin&quot;
  */
  makeSearchPath = ...
</code></pre>
<p>Unfortunately those comments are very inconsistent.</p>
<p>And cause problems if you want to process them with <strong>external tools</strong> or even try to <strong>parse</strong>
them into an Type-AST which could be used <strong>for linting</strong> and other possible features like
<strong>autocompletion</strong>, <strong>typed documentation</strong> or other use-cases of <strong>static code analysis</strong>.</p>
<blockquote>
<p>For simplicity <code>Type:</code> prefixes have been omitted. in the following examples</p>
</blockquote>
<h2 id="type-variables-vs-explicit-any"><a class="header" href="#type-variables-vs-explicit-any">Type variables vs explicit <code>Any</code></a></h2>
<ul>
<li><code>singleton :: a -&gt; [a]</code></li>
<li><code>singleton :: Any -&gt; [Any]</code></li>
<li><code>imap0 :: (int -&gt; a -&gt; b) -&gt; [a] -&gt; [b]</code></li>
</ul>
<blockquote>
<p>Type variables are better than the explicit <code>Any</code> this Project highly recommends to PROHIBIT the use of explicit <code>Any</code> and force users to use type variables.</p>
</blockquote>
<h2 id="lowercase-pascalcase-vs-camelcase"><a class="header" href="#lowercase-pascalcase-vs-camelcase">Lowercase, PascalCase, vs camelCase</a></h2>
<ul>
<li><code>imap0 :: (int -&gt; a -&gt; b) -&gt; [a] -&gt; [b]</code></li>
<li><code>hasAttrByPath :: [String] -&gt; AttrSet -&gt; Bool</code></li>
</ul>
<h2 id="what-types-are-there"><a class="header" href="#what-types-are-there">What types are there</a></h2>
<p>What type is <code>ComparableVal</code>?</p>
<ul>
<li><code>assertOneOf :: String -&gt; ComparableVal -&gt; List ComparableVal -&gt; Bool</code></li>
</ul>
<p>What type is <code>package</code>?</p>
<ul>
<li><code>string -&gt; string -&gt; [package] -&gt; string</code></li>
</ul>
<p>what type is a <code>Derivation</code>?
Is it different from <code>package</code>?</p>
<ul>
<li><code>toDerivation :: Path -&gt; Derivation</code></li>
</ul>
<p>also there is <code>derivation</code> which is written lowercase, is that a typo, or the same type?</p>
<h2 id="are-function-names-required"><a class="header" href="#are-function-names-required">Are function names required?</a></h2>
<p>nixdoc by default maps the <code>Type:</code> comment to the corresponding function.
Sometimes the type-comment didn't include the functions name.</p>
<ul>
<li><code>toDerivation :: Path -&gt; Derivation</code></li>
<li><code>makeSearchPathOutput :: toDerivation :: Path -&gt; Derivation</code></li>
</ul>
<h2 id="should-types-start-in-newlines"><a class="header" href="#should-types-start-in-newlines">Should types start in newlines?</a></h2>
<pre><code class="language-nix">Type: assertOneOf :: String -&gt; ComparableVal -&gt; List ComparableVal -&gt; Bool
</code></pre>
<pre><code class="language-nix">Type:
    assertOneOf :: String -&gt; ComparableVal -&gt; List ComparableVal -&gt; Bool
</code></pre>
<h2 id="many-more"><a class="header" href="#many-more">Many more</a></h2>
<p>All those different subjective opinions on how to write proper docstrings have already let to high inconsistency across <strong>nixpkgs</strong>.</p>
<h2 id="possible-impact"><a class="header" href="#possible-impact">Possible Impact</a></h2>
<p>This project aims to reduce those and provide a consistent ruleset for that.</p>
<p>If it accurately represents the code problems accurate enough,
it might even be valid candidate for static type systems in future nix language versions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="impact"><a class="header" href="#impact">Impact</a></h1>
<p>If some first tools adopt and use the convention we could have</p>
<ul>
<li>documentation</li>
<li>auto-completion on actual code</li>
<li>enhance linting by types</li>
<li>code analysis</li>
<li>tell the developer if his code would not work</li>
<li>many more....</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>This section contains some illustrative examples that show how to practically apply the specification in concrete use-case-scenarios.</p>
<h2 id="short-preview-of-the-basic-syntax"><a class="header" href="#short-preview-of-the-basic-syntax">Short preview of the basic syntax</a></h2>
<pre><code class="language-nix"># lib.lists.any

/* 
    Type: 
        any :: ( a -&gt; Bool ) -&gt; [ a ] -&gt; Bool
         â†‘   â†‘        â†‘        â†‘             â†‘
         |   |        |        |             â””â”€â”€ final return value is a Bool
         |   |        |        â””â”€â”€ The first function returns a function that takes a list of type 'a'      
         |   |        â””â”€â”€ function that takes an 'a' and returns True or False (Boolean)
         |   â””â”€â”€ declares the type as follows
         â””â”€â”€ referenced binding name
*/
any = builtins.any or (pred: foldr (x: y: if pred x then true else y) false);
</code></pre>
<h2 id="first-examples"><a class="header" href="#first-examples">first examples</a></h2>
<pre><code class="language-nix"># lib.lists.remove

/*
    Type:
        remove :: a -&gt; [ a ] -&gt; [ a ]
*/
remove = #...
</code></pre>
<pre><code class="language-nix"># lib.attrsets.hasAttrByPath

/*
Type:
    hasAttrByPath :: [ String ] -&gt; { ... } -&gt; Bool
*/
hasAttrByPath = # ...
</code></pre>
<pre><code class="language-nix">/*
# example file from the dream2nix framework

type:
    depsTree :: DependencyTree

    DependencyTree = { ${name} :: { ${version} :: DependencyAttrs } }
    DependencyAttrs = { { deps :: DependencyTree, derivation :: Derivation } }
*/
depsTree = let 
# ...
</code></pre>
<pre><code class="language-nix">/*
Type:
    getAttrs :: [ String ] -&gt; { ... } -&gt; { ... }
*/
getAttrs = names: attrs: genAttrs names (name: attrs.${name});
</code></pre>
<h2 id="advanced"><a class="header" href="#advanced">Advanced</a></h2>
<h3 id="open-points"><a class="header" href="#open-points">Open points</a></h3>
<p>With <code>Any</code> there is no indication if all arguments must contain the same single type <code>a</code> thus it would be more precise with <strong>type variable</strong> instead of the explicit <code>Any</code> type.</p>
<pre><code class="language-nix"># lib.lists.remove

/*
    Type:
        remove :: a -&gt; [ a ] -&gt; [ a ]
*/
remove = #...
</code></pre>
<p>The following is a hard one. We are not sure yet how to present that type <code>b</code> is present somewhere in a nested set.</p>
<p>It gets returned, if the referenced value is present in the attrSet; default value of type <code>a</code> otherwise.</p>
<p><code>a</code> can be equal to <code>b</code> but generally speaking it doesn't have to.</p>
<pre><code class="language-nix"># lib.attrsets.attrByPath

/* Return an attribute from nested attribute sets.

    Type:
    attrByPath :: [ String ] -&gt; a -&gt; { ... } -&gt; b | a
*/
attrByPath = # ...
</code></pre>
<p>We are not able yet to dynamically create members of an AttrSet from a given type signature.</p>
<pre><code class="language-nix">/*
Type:
    getAttrs :: [ String ] -&gt; { ... } -&gt; { ... }
                    â†‘                      â†‘
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€ The list of String matches the member name of the returned AttrSet

*/
getAttrs = names: attrs: genAttrs names (name: attrs.${name});
</code></pre>
<p>Thus it might make sense to generally allow context on ListItems as follows. (Optional Context)</p>
<pre><code class="language-nix">    getAttrs :: [ name :: String ] -&gt; { ... } -&gt; { [ name :: String ] :: Any }
                    â†‘                                 â†‘
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€ The list of String matches the member-names of the returned AttrSet
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="formals"><a class="header" href="#formals">Formals</a></h1>
<p>The following section specifies how to write <code>type hints</code> as comments</p>
<blockquote>
<p><code>type:</code> Type</p>
</blockquote>
<p>Every specified formal rule has the following format:</p>
<blockquote>
<p>[NT000] - Rule description</p>
</blockquote>
<h2 id="the-rules"><a class="header" href="#the-rules">The rules</a></h2>
<ul>
<li>[NT000] - The Language rules MUST be followed (described in this project)</li>
<li>[NT001] - <code>Type hints</code> can only occur within multiline comments <code>/* */</code></li>
<li>[NT002] - <code>Type:</code> starts the type block. Followed by at least one line-break (case sensitive)</li>
<li>[NT003] - Within one block multiple declarations are allowed.</li>
<li>[NT004] - All notations are <code>PascalCase</code>; starting with capital letters.</li>
<li>[NT005] - Types MUST be chosen from the existing list. see <a href="specification/./basic.html">primitives</a></li>
<li>[NT006] - Operators MUST be chosen from the existing list. see <a href="specification/./operators.html">operators</a></li>
<li>[NT007] - explicit <code>AttrSet</code> and <code>List</code> keywords are PROHIBITED. See the correct usage <a href="specification/./complex.html">here</a></li>
<li>[NT007] - explicit <code>Any</code> is PROHIBITED. Correct usage with type variables see <a href="specification/./type-variables.html">here</a></li>
<li>[NT008] - <a href="specification/./complex.html">complex types</a> MUST include their members explicitly.</li>
<li>[NT009] - Allowing arbitrary values within <a href="specification/./complex.html">complex-types</a> is possible but requires explicit statements.</li>
<li>[NT009] - <code>Type variables</code> must be written in LOWERCASE to prevent confusion.</li>
<li>[NT010] - When using <a href="specification/./operators.html#type-binding">Type bindings</a> it is PROHIBITED to choose names from the <a href="specification/./types.html">reserved list</a></li>
<li>[NT011] - Spaces between Operators (recommended)</li>
<li>... more concrete rules may follow when implementation has started</li>
</ul>
<blockquote>
<p>Hint: The type block is never terminated and expands till to the bottom of the <code>/* multiline comment */</code>. This is actually very close to how comments are parsed today.</p>
</blockquote>
<h3 id="example-of-a-valid-and-nicely-formatted-type-hint"><a class="header" href="#example-of-a-valid-and-nicely-formatted-type-hint">Example of a valid and nicely formatted <code>type hint</code></a></h3>
<blockquote>
<p>Usage of operators will be explained in the following chapters</p>
</blockquote>
<pre><code class="language-nix">  /* Return an attribute from nested attribute sets.
    ...
    Free Text goes here 
    ...
    
    Type:
        attrByPath :: [ String ] -&gt; a -&gt; { ${path} :: b } -&gt; ( a | b )
  */
  attrByPath = ...
</code></pre>
<p>This function takes a path as list of strings and then traverses the attrSet until it may find a value of type 'b' otherwise it returns the default value of type 'a'.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>This chapter clarifies all types.</p>
<p>To Pickup the overview more quickly they can be viewed in the following list.</p>
<p>Every decision and further specification are explained in the corresponding sub-chapters respectively.</p>
<h2 id="list-of-all-types"><a class="header" href="#list-of-all-types">List of all <code>Types</code></a></h2>
<!-- markdownlint-disable MD041 -->
<h3 id="primitives"><a class="header" href="#primitives">Primitives</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Bool</td><td>A value of type boolean can be either <code>true</code> or <code>false</code></td></tr>
<tr><td>Int</td><td>TODO: The classical integer type with 32-bit or 64-bit depending on the current system?</td></tr>
<tr><td>Float</td><td>A float with 64 bits?</td></tr>
<tr><td>String</td><td>A string of any unicode characters</td></tr>
<tr><td>Path</td><td>Path referencing a location or a file. With no assumptions on the existence of that</td></tr>
<tr><td>Null</td><td>The value null</td></tr>
</tbody></table>
</div><!-- markdownlint-disable MD041 -->
<h3 id="complex"><a class="header" href="#complex">Complex</a></h3>
<blockquote>
<p><code>T</code>, <code>U</code>, ...; are placeholders for any types, those MUST be specifically declared on usage</p>
</blockquote>
<hr />
<div class="table-wrapper"><table><thead><tr><th>Annotation</th><th>Type</th><th>Description</th><th>chapter</th></tr></thead><tbody>
<tr><td><code>[T]</code></td><td>List</td><td>List of elements with type <code>T</code> each</td><td><a href="specification/list.html">List</a></td></tr>
<tr><td><code>{N::T}</code></td><td>AttrSet</td><td>AttrSet where member <code>N</code> references value of type <code>T</code></td><td><a href="specification/attrset.html">AttrSet</a></td></tr>
<tr><td><code>T-&gt;U</code></td><td>Lambda</td><td>A function that takes a single argument of type <code>T</code> and returns a value of type <code>U</code></td><td><a href="specification/lambda.html">lambda</a></td></tr>
</tbody></table>
</div>
<blockquote>
<p>More details how to use complex types in the corresponding chapters</p>
</blockquote>
<!-- markdownlint-disable MD041 -->
<!-- markdownlint-disable MD013 -->
<h3 id="composed"><a class="header" href="#composed">Composed</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Composition</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Number</code></td><td><code>Int {or} Float</code></td><td>The <code>Number</code> is either of type <code>Int</code> or of type <code>Float</code></td></tr>
<tr><td><code>Any</code></td><td><code>?</code></td><td>There is no <code>Any</code> type and it is explicitly prohibited to use the Any type. Use type variables instead if you want to allow variable type signatures.</td></tr>
<tr><td><code>StorePath</code></td><td><code>Path</code></td><td>The <code>StorePath</code> is just a meaningful alias of the type <code>Path</code></td></tr>
<tr><td><code>Derivation</code></td><td><code>{ ... }</code></td><td>TODO: <code>Derivation</code> is just a special AttrSet.</td></tr>
<tr><td><code>Package</code></td><td><code>Derivation {or} {...}</code></td><td>TODO: <code>Package</code> is either a Derivation or a special AttrSet with <code>name</code> xy in it.</td></tr>
</tbody></table>
</div>
<blockquote>
<p>used operators are defined in the <a href="specification/operators.html">operators chapter</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitives-1"><a class="header" href="#primitives-1">Primitives</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The following primitive types have been identified.</p>
<p>All other types can be composed from them by using those and the <a href="specification/./operators.html">operators</a>.</p>
<!-- markdownlint-disable MD041 -->
<h3 id="primitives-2"><a class="header" href="#primitives-2">Primitives</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Bool</td><td>A value of type boolean can be either <code>true</code> or <code>false</code></td></tr>
<tr><td>Int</td><td>TODO: The classical integer type with 32-bit or 64-bit depending on the current system?</td></tr>
<tr><td>Float</td><td>A float with 64 bits?</td></tr>
<tr><td>String</td><td>A string of any unicode characters</td></tr>
<tr><td>Path</td><td>Path referencing a location or a file. With no assumptions on the existence of that</td></tr>
<tr><td>Null</td><td>The value null</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="complex-1"><a class="header" href="#complex-1">Complex</a></h1>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>The following complex types have been identified.</p>
<p>All complex types can be composed from Any other types even from themselves by using those and the <a href="specification/./operators.html">operators</a>.</p>
<!-- markdownlint-disable MD041 -->
<h3 id="complex-2"><a class="header" href="#complex-2">Complex</a></h3>
<blockquote>
<p><code>T</code>, <code>U</code>, ...; are placeholders for any types, those MUST be specifically declared on usage</p>
</blockquote>
<hr />
<div class="table-wrapper"><table><thead><tr><th>Annotation</th><th>Type</th><th>Description</th><th>chapter</th></tr></thead><tbody>
<tr><td><code>[T]</code></td><td>List</td><td>List of elements with type <code>T</code> each</td><td><a href="specification/list.html">List</a></td></tr>
<tr><td><code>{N::T}</code></td><td>AttrSet</td><td>AttrSet where member <code>N</code> references value of type <code>T</code></td><td><a href="specification/attrset.html">AttrSet</a></td></tr>
<tr><td><code>T-&gt;U</code></td><td>Lambda</td><td>A function that takes a single argument of type <code>T</code> and returns a value of type <code>U</code></td><td><a href="specification/lambda.html">lambda</a></td></tr>
</tbody></table>
</div>
<blockquote>
<p>More details how to use complex types in the corresponding chapters</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="list"><a class="header" href="#list">List</a></h1>
<h2 id="abstract-definition"><a class="header" href="#abstract-definition">Abstract definition</a></h2>
<p>Let <code>[ a ]</code> be a list where the elements of that list do not have any type constraints.</p>
<p>Then a List of a specific Type <code>[ T ]</code> is a list where all elements <code>a</code> fullfil the type constraint <code>T</code></p>
<blockquote>
<p>A list <code>[]</code> can contain <strong>no</strong>, <strong>one</strong> or <strong>multiple</strong> elements. (0...n)</p>
</blockquote>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<h3 id="list-of-string"><a class="header" href="#list-of-string">list of string</a></h3>
<p><code>[ String ]</code></p>
<h3 id="list-of-string-or-bool"><a class="header" href="#list-of-string-or-bool">list of string or bool</a></h3>
<p><code>[ Number | Bool ]</code></p>
<p>-&gt; see the <code>|</code> {or} operator defined <a href="specification/./operators.html">here</a></p>
<h3 id="empty-list"><a class="header" href="#empty-list">empty list</a></h3>
<p><code>[ ]</code></p>
<h3 id="list-of-any-attrset"><a class="header" href="#list-of-any-attrset">list of any attrSet</a></h3>
<p><code>[ { ... } ]</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attrset"><a class="header" href="#attrset">AttrSet</a></h1>
<h2 id="abstract"><a class="header" href="#abstract">Abstract</a></h2>
<p>An <code>AttrSet</code> type can be thought of as just a list of <code>pair of name and value</code>.</p>
<ul>
<li><code>fst</code> on <code>pair of name and value</code> yields the <code>name</code>.</li>
<li><code>snd</code> on <code>pair of name and value</code> yields the <code>value</code>.</li>
</ul>
<p>Then <code>AttrSet</code> can be written as:</p>
<pre><code class="language-nix">[Pair(name,value)]
</code></pre>
<p>when you reference a specific <strong>name</strong> on an AttrSet; You basically implicitly apply a <code>filter</code> or <code>find</code> operation on that list where the <code>fst</code> of the <code>mapped entry</code> equals the referenced <strong>name</strong></p>
<p>For simplicity this is called a <code>member name</code> from now on, if that name exists.</p>
<p>If that name does not exist it is called <code>non-existing member name</code>.</p>
<h2 id="redefining-some-operators"><a class="header" href="#redefining-some-operators">Redefining some operators</a></h2>
<p><code>::</code>-operator within <code>AttrSet</code> contexts</p>
<p>The <code>::</code>-operator maps the Type of its <code>RHS</code> over the <code>Type</code> on its <code>LHS</code>. It can take an <code>Iterable</code> or a <code>single element</code> on its LHS.</p>
<p>Within Type-declarations for AttrSets it is possible to declare an explicit <code>member name</code> of an AttrSet like this.</p>
<pre><code class="language-nix">  {
    N :: T
  }
</code></pre>
<p>Then <code>N</code> is of type <code>String</code> and <code>N</code> becomes a <code>member name</code> of that AttrSet. The <code>snd</code> operation on the entry of <code>N</code> would yield a value of type <code>T</code>.</p>
<p>Introducing: <code>[ N :: T ]</code>-operator, which can only be used within <code>AttrSet</code> in <code>member name</code> fields.</p>
<p>The <code>[ N :: T ]</code>-operator maps over all <code>member names</code> of an AttrSet <code>[N]</code> and applies the type <code>T</code> to each member name <code>N</code> if not already done by explicit member__ declaration (see above).</p>
<p>When there are AttrSets with dynamic members it is possible to declare all those members at once with the <code>[ N :: T ]</code> and <code>::</code> operator.</p>
<p>Then an AttrSet with list of dynamic members where each member-name <code>N</code> references a <strong>value of type</strong> <code>V</code> can be written as.</p>
<pre><code class="language-nix">  { 
    [ N :: T ] :: V 
  }
</code></pre>
<h3 id="examples-2"><a class="header" href="#examples-2">Examples</a></h3>
<pre><code class="language-nix">  # member '.foo' references a value of type string
  # all other members `*` are of type string and each member reference value of any variable Type.
  { 
    [ name :: String ] :: a, 
    foo :: String 
  }
</code></pre>
<pre><code class="language-nix">  { foo :: a } 
</code></pre>
<pre><code class="language-nix">   {} 
</code></pre>
<p>where the member names `[ N :: T ] are an empty list.</p>
<h2 id="useful--shortcut"><a class="header" href="#useful--shortcut">useful <code>${}</code> Shortcut</a></h2>
<p><code>${N} = [ N :: String ]</code></p>
<p>If we take into account that in AttrSets <code>names</code> (<code>N</code>) are always of type <code>String</code> the user can omit the <code>String</code> Keyword completely, and instead give only the names. <code>N</code></p>
<p>That rule allows for intuitive usage of names within type definitions of an AttrSet</p>
<pre><code class="language-nix">/*
type:
  packageMap :: { 
    ${pname} :: {
      ${version} :: Derivation
    }
  }
*/
packageMap = {
  &quot;gcc-utils&quot; = {
    &quot;1.2.3&quot; = builtins.Derivation {...};
    };
  # ...
  };
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambda"><a class="header" href="#lambda">Lambda</a></h1>
<h2 id="abstract-definition-1"><a class="header" href="#abstract-definition-1">Abstract definition</a></h2>
<p>A lambda is a function that takes exactly one <code>argument</code> and returns exactly one <code>result</code>.</p>
<p>It is denoted as follows:</p>
<pre><code class="language-nix">a -&gt; b
</code></pre>
<p>Where <code>a</code> is the <code>argument</code> and <code>b</code> is the returned <code>result</code>.</p>
<p>Then a typed lambda notation:</p>
<pre><code class="language-nix">T -&gt; G
</code></pre>
<p>Denotes that <code>T</code> is the type of argument <code>a</code> and <code>G</code> is the type of result <code>b</code>.</p>
<blockquote>
<p>In <code>lambda</code> notations arguments do not have names like in e.g. <code>AttrSet</code> because they are positional arguments.</p>
</blockquote>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<h3 id="lambda-that-takes-a-string-and-returns-string"><a class="header" href="#lambda-that-takes-a-string-and-returns-string">Lambda that takes a <code>String</code> and returns <code>String</code></a></h3>
<p><code>String -&gt; String</code></p>
<h3 id="function-that-takes-string-and-number-and-finally-returns-string"><a class="header" href="#function-that-takes-string-and-number-and-finally-returns-string">Function that takes <code>String</code> and <code>Number</code> and finally returns <code>String</code></a></h3>
<p><code>String -&gt; Number -&gt; String</code></p>
<blockquote>
<p>As lambdas can take only one argument, the return type of the first lambda expression is a lambda that takes the second argument and returns the final type.</p>
</blockquote>
<h3 id="function-that-takes-a-function"><a class="header" href="#function-that-takes-a-function">Function that takes a function</a></h3>
<p><code>(String -&gt; String) -&gt; [String] -&gt; [String]</code></p>
<blockquote>
<p>Sometimes parenthesis is necessary to clarify order of evaluation</p>
<p>The <code>()</code> Parenthesis operator is defined <a href="specification/./operators.html">here</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operators"><a class="header" href="#operators">Operators</a></h1>
<p><strong>All Operators SHOULD be used with surrounding whitespace.</strong></p>
<h2 id="-declares-the-type"><a class="header" href="#-declares-the-type"><code>::</code> declares the type</a></h2>
<p>The variable name on the LHS is declared to have the <code>type</code> on the RHS</p>
<p>e.g. <code>name :: String</code></p>
<h2 id="-parenthesis"><a class="header" href="#-parenthesis"><code>()</code> Parenthesis</a></h2>
<p>Parenthesis to clarify order of type evaluation</p>
<p>e.g. <code>( a -&gt; b ) | Bool</code></p>
<h2 id="-separator-for-subsequent-entries-like-in-attrset"><a class="header" href="#-separator-for-subsequent-entries-like-in-attrset"><code>,</code> Separator for subsequent entries (like in AttrSet)</a></h2>
<p>e.g. <code>{ foo :: Number, bar :: String }</code></p>
<h2 id="-syntactic-or"><a class="header" href="#-syntactic-or"><code>|</code> syntactic or</a></h2>
<p>syntactic <code>Or</code> can be used for composition or enums</p>
<p>Let <code>T</code> and <code>U</code> be different Types.
Then the <code>|</code> operator evaluates to either <code>T</code> or <code>U</code>.</p>
<blockquote>
<p>Sometimes within this paper <code>|</code> is written as <code>{or}</code></p>
<p>This is only due to readability and not allowed in the real language</p>
</blockquote>
<h3 id="examples-4"><a class="header" href="#examples-4">Examples</a></h3>
<p><code>Float | Int</code></p>
<p><code>( Number | Bool ) | Int</code></p>
<p><code>{ opt :: Int | String }</code></p>
<pre><code class="language-nix"># lets say we want to create a type which can represent the type of both 'foo' and 'bar'
let
  /*
    Type:
      FooBar = Int | String

      foo :: FooBar
  */
  foo = 1;
  /*
    Type: 
      bar :: FooBar
  */
  bar = &quot;baz&quot;;

in
  # ....

</code></pre>
<h3 id="---arbitrary-input-values"><a class="header" href="#---arbitrary-input-values"><code>...</code> - arbitrary input values</a></h3>
<p>can only be used within an AttrSet to allow <code>Any</code> more <code>name-value pairs</code>.</p>
<p><code>...</code> = <code>${rest} :: a</code> within an AttrSet context</p>
<p>e.g.</p>
<pre><code class="language-nix">/*
  Type: foo :: { bar :: a, ...} -&gt; a
*/
Foo = {bar, ...}@inp:
#...
</code></pre>
<h2 id="-merge-operator"><a class="header" href="#-merge-operator"><code>//</code> merge operator</a></h2>
<p>syntactically <code>merges</code> Types of AttrSets</p>
<p><code>{ foo :: String } // { bar :: Number }</code> =&gt; <code>{ foo :: String, bar :: Number }</code></p>
<p><code>{ foo :: String } // { ${names} :: a }</code> =&gt; <code>{ foo :: String, ${names} :: a  }</code></p>
<p>Overwrites occur like in the nix language itself</p>
<p><code>{ foo :: String } // { foo :: Number }</code> =&gt; <code>{ foo :: Number }</code></p>
<h2 id="-equality-operator"><a class="header" href="#-equality-operator"><code>=</code> equality operator</a></h2>
<p>Allows for <strong>type bindings</strong></p>
<p>Convention: As types always start with Capital letters; Type bindings also start with capital letters.</p>
<p>Binding types to names will allow to specify recursive types, which is required for many structures in nix.</p>
<p>Binding types to intermediate variables makes it harder to see which declaration is related to the actual code.</p>
<p>e.g.</p>
<pre><code class="language-nix">
/*
 Type: 
   DerivationAttrs = { buildInputs :: [ Derivation ], ... }
   MkDerivationAttrs = DerivationAttrs // { buildInputs :: String }
   mkDerivation :: MkDerivationAttrs -&gt; Derivation
*/
mkDerivation = {pname, version, foo, ...}@args: let
# ...

</code></pre>
<p>Those bindings should be scoped with an useful mechanism, which could be:</p>
<ul>
<li>File wide</li>
<li>Project wide</li>
<li>Declaration block</li>
<li>Same scope as the referenced function binding has</li>
</ul>
<p>e.g.</p>
<pre><code class="language-nix">  type:
    Foo = Number
</code></pre>
<h3 id="prohibited-binding"><a class="header" href="#prohibited-binding">prohibited binding</a></h3>
<p>To prevent conflicts and confusion.
<strong>It is strictly prohibited to choose a name your custom type to be the same as:</strong></p>
<ul>
<li>One of the <a href="specification/./types.html">reserved types</a></li>
</ul>
<h2 id="-optional-arguments-in-an-attrset"><a class="header" href="#-optional-arguments-in-an-attrset"><code>?</code> optional arguments in an AttrSet</a></h2>
<p>e.g.  <code>{ opt :: ? Int }</code></p>
<p>Note: The <code>type</code> side contains the <code>?</code> operator.</p>
<h2 id="const-types"><a class="header" href="#const-types">Const types</a></h2>
<p>Instead of assigning types it is allowed to assign a nix-value to the type. Which is then declared constant across that specific type.</p>
<p>e.g. <code>{ foo :: &quot;bar&quot;, bar :: 1 }</code> specifies the name <code>foo</code> to be of value &quot;bar&quot;</p>
<pre><code class="language-nix">{
  foo = &quot;bar&quot;;
  bar = 1;
}
</code></pre>
<p>concrete use-case</p>
<pre><code class="language-nix">/*
    type:
        derivation :: { 
            type: &quot;derivation&quot;,
            ...
        }
*/
derivation = ...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-variables"><a class="header" href="#type-variables">Type Variables</a></h1>
<h2 id="abstract-1"><a class="header" href="#abstract-1">Abstract</a></h2>
<p>As the explicit <code>Any</code> keyword is prohibited. Even there is no such <code>Any</code> type.</p>
<p>It is of course possible to construct the <code>Any</code> type and use it properly but in good type systems there is no need for that type.</p>
<p>The <code>Any</code> type is covered from <code>Polymorphism</code> with the usage of <code>type variables</code>.</p>
<p>Type variables can have any name but it is usually considered best practice to choose either letters from the latin alphabet or use meaningful names.</p>
<blockquote>
<p><code>Type variables</code> must be written in LOWERCASE to prevent confusion.</p>
</blockquote>
<h2 id="examples-5"><a class="header" href="#examples-5">Examples</a></h2>
<p>The following function signatures from <code>nix</code> and <code>nixpkgs</code> are written most clearly with <code>type variables</code></p>
<h3 id="builtinsmap"><a class="header" href="#builtinsmap">builtins.map</a></h3>
<pre><code class="language-nix">( a -&gt; b ) -&gt; [a] -&gt; [b]
</code></pre>
<h3 id="builtinscatattrs"><a class="header" href="#builtinscatattrs">builtins.catAttrs</a></h3>
<pre><code class="language-nix">String -&gt; [ { ${name} :: a } ] -&gt; [a]
</code></pre>
<h3 id="libattrsetsattrbypath"><a class="header" href="#libattrsetsattrbypath">lib.attrsets.attrByPath</a></h3>
<pre><code class="language-nix">[ String ] -&gt; a -&gt; { ${path} :: b } -&gt; (a | b)
</code></pre>
<h3 id="builtinsmapattrs"><a class="header" href="#builtinsmapattrs">builtins.mapAttrs</a></h3>
<pre><code class="language-nix">(String -&gt; a -&gt; b) -&gt; { ${name} :: a } -&gt; { ${name} :: b }
</code></pre>
<h3 id="builtinssort"><a class="header" href="#builtinssort">builtins.sort</a></h3>
<pre><code class="language-nix">(a -&gt; b -&gt; Bool) -&gt; [a] -&gt; [b]
</code></pre>
<h2 id="namespaces"><a class="header" href="#namespaces">Namespaces</a></h2>
<p>Type variables are currently the best way to properly use polymorphism in type signatures.
But using them requires the underlying parser and the user need to understand some concepts like namespaces and shadowing.</p>
<p>This section orients itself on the <em>Haskell type variables</em>. See here for <a href="https://downloads.haskell.org/ghc/latest/docs/users_guide/exts/scoped_type_variables.html">their rules</a></p>
<blockquote>
<p>In nix we don't have the same syntax as haskell has but the basic principles and core concept will be adopted from the parser.</p>
</blockquote>
<h3 id="bigger-sets-with-nested-type-variables"><a class="header" href="#bigger-sets-with-nested-type-variables">Bigger sets with nested type variables</a></h3>
<p>sometime it is possible to have expressions, that contain multiple levels of nestings, where also different hierarchies of <code>type variables</code> must interact with each other.</p>
<pre><code class="language-nix">{ foo :: a } -&gt; {
  nestedFunction :: a -&gt; b,
  bar :: ( b -&gt; c ) -&gt; [c] -&gt; [b]
}
</code></pre>
<p>This seem a little complex now, because the parent function returns an AttrSet that includes function signatures using the same <code>type variables</code> as the outermost function itself.</p>
<blockquote>
<p><strong>There is actually a very strict and proven ruleset for that exact problem out there.</strong></p>
<p>The Haskell Ruleset for <a href="https://downloads.haskell.org/ghc/latest/docs/users_guide/exts/scoped_type_variables.html">scoped type variables</a></p>
<p>(see also above).</p>
</blockquote>
<h2 id="type-variables-with-constraints"><a class="header" href="#type-variables-with-constraints">Type Variables with constraints</a></h2>
<p>Sometime we have variable types in signatures, but cannot allow any type for the variable.
Then we could construct a type and assign it like this.</p>
<pre><code class="language-nix">  Foo = ( String | Path )
  Foo -&gt; Foo 
</code></pre>
<blockquote>
<p>This is already allowed syntax in the proposed type system. There are no additional changes that need to be made.</p>
<p>Sometimes there might be more than one expression necessary to express the type of a function.</p>
</blockquote>
<p>Also this means that the annotated function might take a <code>String</code> or a <code>Path</code>, and also returns them.
If that function takes a <code>String</code> it will return the same <code>String</code> type. Once <code>Foo</code> evaluates to type <code>String</code> every occurrence of <code>Foo</code> is then of type <code>String</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nix"><a class="header" href="#nix">Nix</a></h1>
<h2 id="the-language-fundamentals"><a class="header" href="#the-language-fundamentals">The language fundamentals</a></h2>
<p>It is very desireable to build a solid set of type signatures for the most basic operators in <code>nix</code>.</p>
<p>Those are:</p>
<ul>
<li>language syntax</li>
<li><a href="nix/./operations.html">Operations</a></li>
<li><a href="nix/./builtins.html">Builtins</a></li>
</ul>
<blockquote>
<p>If those basic functionality from a type perspective of the language itself is clarified.</p>
<p>this opens a whole new spectrum of possibilities like <strong>type inference</strong> or <strong>type checking</strong>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operations"><a class="header" href="#operations">Operations</a></h1>
<p>The official documentation about the operators in nix can be found <a href="https://nixos.org/manual/nix/stable/language/operators.html">here</a></p>
<p>ðŸš§ðŸš§ðŸš§ This site is WIP</p>
<h2 id="official-list"><a class="header" href="#official-list">Official List</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Syntax</th><th>Associativity</th><th>Precedence</th></tr></thead><tbody>
<tr><td>Attribute selection</td><td><em>AttrSet</em> <code>.</code> <em>AttrPath</em> [ <code>or</code> <em>expr</em> ]</td><td>none</td><td>1</td></tr>
<tr><td>Function application</td><td><em>func</em> <em>expr</em></td><td>left</td><td>2</td></tr>
<tr><td>Arithmetic negation</td><td><code>-</code> <em>number</em></td><td>none</td><td>3</td></tr>
<tr><td>Has attribute</td><td><em>AttrSet</em> <code>?</code> <em>AttrPath</em></td><td>none</td><td>4</td></tr>
<tr><td>ist concatenation</td><td><em>list</em> <code>++</code> <em>list</em></td><td>right</td><td>5</td></tr>
<tr><td>Multiplication</td><td><em>number</em> <code>*</code> <em>number</em></td><td>left</td><td>6</td></tr>
<tr><td>Division</td><td><em>number</em> <code>/</code> <em>number</em></td><td>left</td><td>6</td></tr>
<tr><td>Subtraction</td><td><em>number</em> <code>-</code> <em>number</em></td><td>left</td><td>7</td></tr>
<tr><td>Addition</td><td><em>number</em> <code>+</code> <em>number</em></td><td>left</td><td>7</td></tr>
<tr><td>String concatenation</td><td><em>string</em> <code>+</code> <em>string</em></td><td>left</td><td>7</td></tr>
<tr><td>Path concatenation</td><td><em>path</em> <code>+</code> <em>path</em></td><td>left</td><td>7</td></tr>
<tr><td>Path and string concatenation</td><td><em>path</em> <code>+</code> <em>string</em></td><td>left</td><td>7</td></tr>
<tr><td>String and path concatenation</td><td><em>string</em> <code>+</code> <em>path</em></td><td>left</td><td>7</td></tr>
<tr><td>Logical negation (<code>NOT</code>)</td><td><code>!</code> <em>bool</em></td><td>none</td><td>8</td></tr>
<tr><td>Update</td><td><em>AttrSet</em> <code>//</code> <em>AttrSet</em></td><td>right</td><td>9</td></tr>
<tr><td>Less than</td><td><em>expr</em> <code>&lt;</code> <em>expr</em></td><td>none</td><td>10</td></tr>
<tr><td>Less than or equal to</td><td><em>expr</em> <code>&lt;=</code> <em>expr</em></td><td>none</td><td>10</td></tr>
<tr><td>Greater than</td><td><em>expr</em> <code>&gt;</code> <em>expr</em></td><td>none</td><td>10</td></tr>
<tr><td>Greater than or equal to</td><td><em>expr</em> <code>&gt;=</code> <em>expr</em></td><td>none</td><td>10</td></tr>
<tr><td>Equality</td><td><em>expr</em> <code>==</code> <em>expr</em></td><td>none</td><td>11</td></tr>
<tr><td>Inequality</td><td><em>expr</em> <code>!=</code> <em>expr</em></td><td>none</td><td>11</td></tr>
<tr><td>Logical conjunction (<code>AND</code>)</td><td><em>bool</em> <code>&amp;&amp;</code> <em>bool</em></td><td>left</td><td>12</td></tr>
<tr><td>Logical disjunction (<code>OR</code>)</td><td><em>bool</em> <code>\|\|</code> <em>bool</em></td><td>left</td><td>13</td></tr>
<tr><td>Logical implication</td><td><em>bool</em> <code>-&gt;</code> <em>bool</em></td><td>none</td><td>14</td></tr>
</tbody></table>
</div>
<h2 id="type-signatures"><a class="header" href="#type-signatures">Type signatures</a></h2>
<p>From a type perspective those operators can be seen as lambda functions. Every operator takes arguments of one type and returns a type.
The following list was created to clarify the type signatures.</p>
<p>Some operators take one or two arguments, they can either take them from left or right hand side.</p>
<h3 id="some-formals"><a class="header" href="#some-formals">Some formals</a></h3>
<p>for simplicity</p>
<ul>
<li><code>R</code> is used as <code>Right hand side</code> type.</li>
<li><code>L</code> is used as <code>Left hand side</code> type.</li>
<li>When using the proposed lambda notation, the first argument is always <code>LHS</code> and the second the <code>RHS</code> of the discussed operator.</li>
<li><code>T,U,W</code> are used as generic Type variables mostly do denote the resulting type, or types of free variables.</li>
<li><code>a</code>,<code>b</code>,... can be of any type. They are type variables.</li>
<li><code>x</code> is a functions input value</li>
<li><code>y</code> is a functions return value</li>
</ul>
<h3 id="---attribute-selection"><a class="header" href="#---attribute-selection">'.' - Attribute selection</a></h3>
<p>Usage of the (<code>.</code>) operator:</p>
<p><code>L</code> must be an AttrSet, and <code>R</code> must evaluate to type <code>String</code></p>
<p>If R itself contains an expression this is parenthesized with the <code>${ }</code> operator.
This operator tells the parser to evaluate the expression in <code>R</code> before passing it to the (<code>.</code>) function.</p>
<pre><code class="language-nix"> L(.)R = L.R 
</code></pre>
<pre><code class="language-nix"> L(.)R = L -&gt; R -&gt; T
 L(.)R :: { ${name} :: a } -&gt; String -&gt; a
</code></pre>
<h3 id="function-application"><a class="header" href="#function-application">Function application</a></h3>
<p>Let <code>f</code> be a function; <code>x</code> its applied argument and <code>y</code> the applied function result.</p>
<pre><code class="language-nix"> y = f x
</code></pre>
<p>For comprehensiveness let the type signature of the above function be <code>L</code> and the applied argument <code>R</code>.</p>
<p>blow the argument <code>R</code> is applied to a function of type <code>L</code>.</p>
<pre><code class="language-nix"> L R = L -&gt; R -&gt; T
 L R :: (a -&gt; b) -&gt; a -&gt; b 
</code></pre>
<h3 id="----minus-operator"><a class="header" href="#----minus-operator">'-' - minus operator</a></h3>
<pre><code class="language-nix"> y = x - 1
</code></pre>
<blockquote>
<p>(<code>-</code>) is a special case where the <code>RHS</code> is applied first to the function.
So if the <code>LHS</code> was omitted it gets the value <code>0</code> as type <code>Int</code>.</p>
</blockquote>
<pre><code class="language-nix"> L(-)R :: R -&gt; L -&gt; T
 (-) :: ( Int | Float ) -&gt; ( Int | Float | 0 ) -&gt; (Int | Float)
</code></pre>
<p>The minus operator is a dependent type
It depends on the received argument value</p>
<ul>
<li>If it receives two <code>Int</code> types it returns <code>Int</code></li>
<li>but if one or both of its arguments is of type <code>Float</code> it returns type <code>Float</code></li>
<li>The type signature is correct using the <code>Number</code> type, but it lacks the information about its <code>value dependency</code>.</li>
</ul>
<h3 id="---plus-operator"><a class="header" href="#---plus-operator">'+' - plus operator</a></h3>
<h3 id="---has-attribute"><a class="header" href="#---has-attribute">'?' - Has attribute</a></h3>
<h3 id="---list-concatenation"><a class="header" href="#---list-concatenation">'++' - List concatenation</a></h3>
<h3 id="----comparison"><a class="header" href="#----comparison">'&lt;' '&gt;' - comparison</a></h3>
<h3 id="---equality"><a class="header" href="#---equality">'==' - Equality</a></h3>
<h3 id="---inequality"><a class="header" href="#---inequality">'!=' - Inequality</a></h3>
<h3 id="---multiplication"><a class="header" href="#---multiplication">'*' - Multiplication</a></h3>
<h3 id="---negation"><a class="header" href="#---negation">'!' - Negation</a></h3>
<h3 id="---update"><a class="header" href="#---update">'//' - Update</a></h3>
<h3 id="------logical"><a class="header" href="#------logical">'&amp;&amp;' '||' '-&gt;' - Logical</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="builtins"><a class="header" href="#builtins">Builtins</a></h1>
<p>This section contains the proof that all nix <code>builtins</code> can be meaningfully and correctly annotated with the proposed type system.</p>
<p>There are currently <strong>89</strong> builtin functions, that can be discovered with</p>
<blockquote>
<p>run <code>nix __dump-builtins</code></p>
</blockquote>
<p>Every builtins signature can be found below (sorted alphabetically)</p>
<blockquote>
<p>Following symbols are used below</p>
<ul>
<li>âœ… - Compliant</li>
<li>âš ï¸ - Under construction.</li>
</ul>
</blockquote>
<h2 id="builtins---todo-the-type-signatures-are-not-compliant-yet"><a class="header" href="#builtins---todo-the-type-signatures-are-not-compliant-yet">Builtins - TODO: The type signatures are not compliant yet</a></h2>
<p>{{#include ../generated/builtin-types.md}}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage"><a class="header" href="#usage">Usage</a></h1>
<p>The goal was to create a system that can add <code>type hints</code> to every expression in nix.</p>
<p>A nix file can contain many possible things.</p>
<p>So what kind of expressions and formats does the <code>RFC</code> need to support?</p>
<ul>
<li>named function expression.</li>
<li>anonymous functions.</li>
<li>named variables.</li>
</ul>
<p>In any possible way nix has only expressions thus if this project covers all kind of expressions, it covers the complete nix language.</p>
<p>The following can be imported as a function called <code>foo</code> as the parent folder is named <code>foo</code> and contains a <code>default.nix</code></p>
<pre><code class="language-nix"># /foo/default.nix

{lib, ...}:
let
    applyIt = fn: fn 10;
#....
in
    act: applyIt act
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributors"><a class="header" href="#contributors">Contributors</a></h1>
<p>Thanks to all people who contributed to this project. (if agreed) github handles will be published here.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
