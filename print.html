<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Nix Types - first considerations</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/highlight-dark.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">2.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="specification/formals.html"><strong aria-hidden="true">3.</strong> Formals</a></li><li class="chapter-item expanded "><a href="specification/grammar.html"><strong aria-hidden="true">4.</strong> Grammar</a></li><li class="chapter-item expanded "><a href="specification/types.html"><strong aria-hidden="true">5.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="specification/basic.html"><strong aria-hidden="true">5.1.</strong> Primitives</a></li><li class="chapter-item expanded "><a href="specification/complex.html"><strong aria-hidden="true">5.2.</strong> Complex</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="specification/list.html"><strong aria-hidden="true">5.2.1.</strong> List</a></li><li class="chapter-item expanded "><a href="specification/attrset.html"><strong aria-hidden="true">5.2.2.</strong> AttrSet</a></li><li class="chapter-item expanded "><a href="specification/lambda.html"><strong aria-hidden="true">5.2.3.</strong> Lambda</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="specification/operators.html"><strong aria-hidden="true">6.</strong> Operators</a></li><li class="chapter-item expanded "><a href="specification/type-variables.html"><strong aria-hidden="true">7.</strong> Type Variables</a></li><li class="chapter-item expanded "><a href="nix/index.html"><strong aria-hidden="true">8.</strong> Nix primitive types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="nix/operations.html"><strong aria-hidden="true">8.1.</strong> Operations</a></li><li class="chapter-item expanded "><a href="nix/builtins.html"><strong aria-hidden="true">8.2.</strong> Builtins</a></li></ol></li><li class="chapter-item expanded "><a href="specification/usage.html"><strong aria-hidden="true">9.</strong> Usage</a></li><li class="chapter-item expanded "><a href="use-case.html"><strong aria-hidden="true">10.</strong> Use-cases</a></li><li class="chapter-item expanded "><a href="contributors.html"><strong aria-hidden="true">11.</strong> Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Nix Types - first considerations</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/hsjobeki/nix-types" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-code-fork"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This (Draft) targets the <code># Type</code> field declared in <a href="https://github.com/NixOS/rfcs/pull/145">RFC-145</a></p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>By specifying the syntax of the type section within nix this opens a wide range of possibilities.</p>
<ul>
<li>consistent function / API documentation.</li>
<li>Type checking - whether you call a function with the expected types.</li>
<li>Language Server (LSP) support - display inline or hover type signatures.</li>
<li>Encourage Modular architectures, with well-defined and documented interfaces.</li>
<li>Static type checking (Partial)</li>
</ul>
<h2 id="detailed-implementation"><a class="header" href="#detailed-implementation">Detailed implementation</a></h2>
<p>I propose to formulate a syntax for the <code># Type</code> section.</p>
<h3 id="no-need-to-use-code-brackets"><a class="header" href="#no-need-to-use-code-brackets">No need to use code brackets</a></h3>
<p>using single or triple ``` (backticks) is not necessary. The complete <code># Type</code> section allows writing one single <code>type expression</code>. The syntax of that is specified in the following.</p>
<h3 id="builds-on-top-of-dynamic-types"><a class="header" href="#builds-on-top-of-dynamic-types">Builds on top of dynamic types</a></h3>
<p>Type information from comments can; just like in the latest js-docs; be used as a source for checking the correctness of code.
We could imagine static type checking to work in symbiotic ways with dynamic type checking, such as YANTS (by TVL).</p>
<h3 id="syntax-follows-nix"><a class="header" href="#syntax-follows-nix">Syntax follows nix</a></h3>
<p>The syntax is mainly inspired and as close as possible to the Nix language. Everyone who knows Nix can easily learn the type-language for it.
There are only very few modifications that are self-explaining and intuitive. While we could imagine a way more complex language, that allows expressing every last detailed relationship.
We think it is more important to provide a good abstraction and find the right compromise between simplicity and expressiveness.</p>
<h2 id="comparison-nixos-modules-system"><a class="header" href="#comparison-nixos-modules-system">Comparison nixOS-modules system</a></h2>
<p>In general, developers must break complex parts into modules.
Allowing them to follow the SOLID principles. Where you could write the interface definition and then develop or refactor the module behind that interface.
As long as the interface stays the same or is downwards compatible nothing in your software breaks.
This property is a very essential feature for writing stable and extendable code.</p>
<p>Nix offers nixos-modules to write such modules and interface declarations. However, those declarations are boilerplate codes that may run during evaluation time.
And also increases complexity as a lot is going on with <code>merge behavior</code> <code>priority (e.g. mkForce)</code> and so on.
Also, it is not clear what is validated and how much it costs in terms of additional runtime overhead.
With type annotations, this can be improved. It is not considered mutually exclusive but rather inclusive to use both worlds together.
Validate at runtime what cannot be known statically (before runtime) and validate statically once you are sure about something in a static context. (This is essentially called a 'gradual' type system)
A good type system would offer both and even detect automatically when to run the check.</p>
<p>Thanks to @roberth and @theophane to point me towards this.</p>
<h2 id="future-work"><a class="header" href="#future-work">Future Work</a></h2>
<ul>
<li>In the Future, the syntax could be integrated into the Nix language. With optional typings; Just like in Python or Javascript.</li>
<li>Interface documentation could then be generated from the nix language itself if types were specified.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>This repo will soon provide a syntax checker. Which will check the type syntax.</p>
<p>Type-checking itself will not happen yet.</p>
<p>TODO: Fill this section to embrace consistent documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="formals"><a class="header" href="#formals">Formals</a></h1>
<h2 id="as-the-annotation-references-to-exactly-one-expression-there-is-only-one-type-expression-possible"><a class="header" href="#as-the-annotation-references-to-exactly-one-expression-there-is-only-one-type-expression-possible">As the annotation references to exactly one expression. There is only one type expression possible</a></h2>
<h2 id="all-notations-are-pascalcase"><a class="header" href="#all-notations-are-pascalcase">All notations are PascalCase</a></h2>
<p>PascalCase with a starting uppercase letter. This is also in other languages a known convention for <code>types</code> or <code>classes</code></p>
<h2 id="types-must-be-chosen-from-the-existing-list"><a class="header" href="#types-must-be-chosen-from-the-existing-list">Types MUST be chosen from the existing list</a></h2>
<p>see <a href="specification/./basic.html">primitives</a></p>
<h2 id="operators-must-be-chosen-from-the-existing-list"><a class="header" href="#operators-must-be-chosen-from-the-existing-list">Operators MUST be chosen from the existing list</a></h2>
<p>see <a href="specification/./operators.html">operators</a></p>
<h2 id="explicit-attrset-and-list-keywords-are-prohibited"><a class="header" href="#explicit-attrset-and-list-keywords-are-prohibited">explicit <code>AttrSet</code> and <code>List</code> keywords are PROHIBITED</a></h2>
<p>See the correct usage <a href="specification/./complex.html">here</a></p>
<h2 id="complex-types-must-include-their-members-explicitly"><a class="header" href="#complex-types-must-include-their-members-explicitly"><a href="specification/./complex.html">complex types</a> MUST include their members explicitly</a></h2>
<p>There is no <code>AttrSet</code> and no <code>List</code> keyword.</p>
<h2 id="explicit-any-is-prohibited"><a class="header" href="#explicit-any-is-prohibited">explicit <code>Any</code> is PROHIBITED</a></h2>
<p>Correct usage with type variables see <a href="specification/./type-variables.html">here</a></p>
<h2 id="allowing-arbitrary-values-within-complex-types"><a class="header" href="#allowing-arbitrary-values-within-complex-types">Allowing arbitrary values within <a href="specification/./complex.html">complex-types</a></a></h2>
<p>It is possible to allow arbitrary values within complex types, but it requires an explicit statement.</p>
<blockquote>
<p>There is no implicit any.</p>
</blockquote>
<h2 id="type-variables-must-be-written-in-lowercase-to-prevent-confusion"><a class="header" href="#type-variables-must-be-written-in-lowercase-to-prevent-confusion"><code>Type variables</code> must be written in LOWERCASE to prevent confusion</a></h2>
<p>They are used instead of the <code>Any</code> Keyword.</p>
<h2 id="for-type-bindings-it-is-prohibited-to-choose-names-from-the-reserved-list"><a class="header" href="#for-type-bindings-it-is-prohibited-to-choose-names-from-the-reserved-list">For <a href="specification/./operators.html#type-binding">Type bindings</a> it is PROHIBITED to choose names from the <a href="specification/./types.html">reserved list</a></a></h2>
<p>This will help to keep the code clean. Reduces complexity, resolves for shadowing and namespace conflicts, with global names.</p>
<h2 id="optional-spaces-between-operators-are-recommended"><a class="header" href="#optional-spaces-between-operators-are-recommended">[Optional] Spaces between Operators are recommended</a></h2>
<p>This follows the nix syntax rules. The symbols and grammar rules of the nix language are adopted.</p>
<blockquote>
<p>Spaces are required where they would be required in valid nix syntax.
This will be quite intuitive</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tokens"><a class="header" href="#tokens">Tokens</a></h1>
<h2 id="the-following-tokens-do-exist"><a class="header" href="#the-following-tokens-do-exist">The following tokens do exist</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Token</th><th>Name</th><th>Purpose</th></tr></thead><tbody>
<tr><td>{}</td><td>Left / Right Braces</td><td>Set Types; Interpolation together with the $-Token;</td></tr>
<tr><td>[]</td><td>Left / Right Brackets</td><td>List Types</td></tr>
<tr><td>()</td><td>Left / Right Parens</td><td>Structure Types,override precedence</td></tr>
<tr><td>@</td><td>At</td><td>Binding Typed values to names</td></tr>
<tr><td>::</td><td>Double Colon</td><td>Declares the type (RHS) of name (LHS)</td></tr>
<tr><td>.</td><td>Dot</td><td>Used to create explicit float values; Usage for accessing child properties in sets is not yet implemented. Some usage example: <code>0.1</code> <code>.5e-9</code> <code>5.e2</code> (This is just native nix)</td></tr>
<tr><td>?</td><td>Question</td><td>Optional properties of sets</td></tr>
<tr><td>;</td><td>Semicolon</td><td>Terminate set entries</td></tr>
<tr><td>-&gt;</td><td>Implication</td><td>Define Lambdas e.g. Int -&gt; String</td></tr>
<tr><td>//</td><td>Update</td><td>Update Attribute Set Types. Can be used to partially update and insert name-value-types</td></tr>
<tr><td>-</td><td>Sub</td><td>Used for explicit negative numbers (-2.0), subtraction is NOT supported (e.g 3 - 1)</td></tr>
<tr><td>&lt;&gt;</td><td>Path</td><td>Define valid paths as explicit values</td></tr>
<tr><td>|</td><td>Pipe</td><td>Create Type-Unions e.g. Int | Float</td></tr>
<tr><td>${}</td><td>Interpolation</td><td>Used for naming / referring to dynamic names</td></tr>
<tr><td>&quot;</td><td>String body (single-line)</td><td>explicit string values</td></tr>
<tr><td>''</td><td>String body (multi-line)</td><td>explicit string values</td></tr>
<tr><td><code>[0-9]*</code></td><td>Integer</td><td>explicit integer values</td></tr>
</tbody></table>
</div>
<h3 id="tokens-removed"><a class="header" href="#tokens-removed">Tokens removed</a></h3>
<p>In contrast to the default nix language, some tokens do not exist and may even result in an error.</p>
<div class="table-wrapper"><table><thead><tr><th>Token</th><th>Name</th><th>Purpose</th></tr></thead><tbody>
<tr><td>,</td><td>Comma</td><td>Originally used for separation in lambda-patterns, replaced by ; (Semicolon)</td></tr>
<tr><td>:</td><td>Colon</td><td>Originally used for lambda, patterns; in Type context replaced by -&gt;</td></tr>
<tr><td>=</td><td>Assign</td><td>Does not exists, use :: (Double Colon) to declare</td></tr>
<tr><td>++</td><td>Concat</td><td>Does not exists, use | (Pipe) to create list unions</td></tr>
<tr><td>/</td><td>Div</td><td>Not used</td></tr>
<tr><td>/**/</td><td>Multiline Comment</td><td>Not used</td></tr>
<tr><td>+</td><td>Add</td><td>Not used</td></tr>
<tr><td>*</td><td>Mul</td><td>Not used</td></tr>
<tr><td>&amp;&amp;</td><td>And</td><td>not used</td></tr>
<tr><td>||</td><td>Or</td><td>not used, use single | (Pipe)</td></tr>
<tr><td>&lt; &lt;=, =&gt;, &gt;</td><td>Less, Less or equal, More or equal, More</td><td>comparison not used</td></tr>
</tbody></table>
</div>
<h2 id="the-following-keywords-do-exist"><a class="header" href="#the-following-keywords-do-exist">The following keywords do exist</a></h2>
<p>Only the <code>let .. in</code> keywords are supported.</p>
<div class="table-wrapper"><table><thead><tr><th>Keyword</th><th>Purpose</th></tr></thead><tbody>
<tr><td>let</td><td>declaration block</td></tr>
<tr><td>in</td><td>what is yielded</td></tr>
</tbody></table>
</div>
<h2 id="keywords-removed"><a class="header" href="#keywords-removed">Keywords removed</a></h2>
<p>As complexity is already quite high. It is considered best to not support the following keywords in the type language.</p>
<div class="table-wrapper"><table><thead><tr><th>Keyword</th><th></th></tr></thead><tbody>
<tr><td>assert</td><td></td></tr>
<tr><td>if</td><td></td></tr>
<tr><td>else</td><td></td></tr>
<tr><td>then</td><td></td></tr>
<tr><td>inherit</td><td></td></tr>
<tr><td>or</td><td></td></tr>
<tr><td>rec</td><td></td></tr>
<tr><td>with</td><td></td></tr>
</tbody></table>
</div>
<h3 id="reserved-types"><a class="header" href="#reserved-types">Reserved Types</a></h3>
<p>All types are written in Uppercase by convention to visually distinguish them from variables and actual values.</p>
<p>Some composed types are handled as native types as well. They are well-defined internally but can be used natively in the type language.</p>
<div class="table-wrapper"><table><thead><tr><th>Keyword</th></tr></thead><tbody>
<tr><td>Bool</td></tr>
<tr><td>Int</td></tr>
<tr><td>Float</td></tr>
<tr><td>String</td></tr>
<tr><td>Path</td></tr>
<tr><td>Null</td></tr>
<tr><td>Number</td></tr>
<tr><td>Derivation</td></tr>
</tbody></table>
</div>
<h2 id="_internal-context"><a class="header" href="#_internal-context">_Internal context</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Context</th><th>Purpose</th></tr></thead><tbody>
<tr><td>MultilineCommentBody</td><td>Initial Context, every character is just the content of the comment.</td></tr>
<tr><td>TypeBlock</td><td>Started by <code>{whitespace}Type:</code>; Every following character is tokenized with the type grammar.</td></tr>
<tr><td>ExampleBlock</td><td>Started by <code>{whitespace}Example:</code>; Everything followed is just a comment string content. Token may not be needed?</td></tr>
<tr><td>StringBody; StringEnd; Interpol; InterpolStart; Path</td><td>Regular nix tokenization context</td></tr>
</tbody></table>
</div>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<p>-- under construction --</p>
<p>The syntax very closely follows the Nix syntax to make writing types intuitive for Nix users. Although the language is inspired by Haskell, not every Nix user may be familiar with Haskell.</p>
<h3 id="legacy-let"><a class="header" href="#legacy-let">Legacy let</a></h3>
<p>Did you know the <code>legacy let</code>? Don't bother it is legacy ^^ ;-). Legacy let is not supported by the type language.
In general, every type is defined in a type expression.</p>
<p>e.g.</p>
<pre><code class="language-hs">Int | Bool
</code></pre>
<p>is a type expression; - but also</p>
<pre><code class="language-hs">let
Foo :: Int;
in
Foo | Bool
</code></pre>
<p>Those two examples contain essentially almost every rule for writing type expressions.</p>
<p>As shown in general there are two levels of type expression.</p>
<ul>
<li>Type-expression</li>
<li>Simple Type-expression</li>
</ul>
<p>The everything is a <code>Type Expression</code> but in certain places you can only write <code>simple type expression</code>. This behavior is not invented with the type language; it is derived from nix.
Where the same principles apply.</p>
<p>For example Simple type expressions do not ally writing <code>let ... in</code>.</p>
<pre><code class="language-hs">[ let T :: Int in T ]
</code></pre>
<p>is just NOT allowed.
There are certain places within the syntax where you can only write simple expressions such as:</p>
<pre><code class="language-hs">[ {SIMPLE} ] -&gt; [ Int | String ]
</code></pre>
<h2 id="root-ident"><a class="header" href="#root-ident">Root Ident</a></h2>
<p>Currently, there are many so-called root ident nodes.</p>
<p>Example:</p>
<pre><code class="language-nix">    mapAttrs :: (String -&gt; Any -&gt; Any) -&gt; AttrSet -&gt; AttrSet
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>This chapter clarifies all types.</p>
<p>To Pickup the overview more quickly they can be viewed in the following list.</p>
<p>Every decision and further specification are explained in the corresponding sub-chapters respectively.</p>
<h2 id="list-of-all-types"><a class="header" href="#list-of-all-types">List of all <code>Types</code></a></h2>
<!-- markdownlint-disable MD041 -->
<h3 id="primitives"><a class="header" href="#primitives">Primitives</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Bool</td><td>A value of type boolean can be either <code>true</code> or <code>false</code></td></tr>
<tr><td>Int</td><td>TODO: The classical integer type with 32-bit or 64-bit depending on the current system?</td></tr>
<tr><td>Float</td><td>A float with 64 bits?</td></tr>
<tr><td>String</td><td>A string of any unicode characters</td></tr>
<tr><td>Path</td><td>Path referencing a location or a file. With no assumptions on the existence of that</td></tr>
<tr><td>Null</td><td>The value null</td></tr>
</tbody></table>
</div>
<h2 id="the-any-type"><a class="header" href="#the-any-type">The <code>Any</code> type</a></h2>
<p>The <code>Any</code> type is often used to explicitly allow arbitrary values. However,
the Any type is complex and doesn't add much value to a type system. Instead, we should use type variables whenever possible.</p>
<p>Interestingly there are two different <code>Any</code> types:</p>
<p>e.g. If we look at CUE-lang (which is also inspired by nix)</p>
<blockquote>
<p>CUE defines the values bottom, or error, (denoted <em>|</em>) that is an instance of all types and top, or any, (denoted _) of which all types are an instance.</p>
</blockquote>
<ul>
<li>
<p><code>TOP any</code> all types are an instance of that. You can imagine it as the TOP-most set, that includes every type. But no value has that type.</p>
</li>
<li>
<p><code>Bottom any</code> which is an instance of all types. This is kind of the imaginary value that has
the any type. Still, doesn't contain any value. Which could also be denoted: <code>Never</code> or <code>Empty Type</code> it is a type that is the subtype of any type.</p>
</li>
</ul>
<p>The following is a nice quote from the Typescript world</p>
<blockquote>
<p>The any type is so dangerous because it exists outside of the type tree.
It is both a top and bottom type.
Everything can be assigned to it and it can be assigned to everything else. ...</p>
</blockquote>
<!-- markdownlint-disable MD041 -->
<h3 id="complex"><a class="header" href="#complex">Complex</a></h3>
<blockquote>
<p><code>T</code>, <code>U</code>, ...; are placeholders for any types, those MUST be specifically declared on usage</p>
</blockquote>
<hr />
<div class="table-wrapper"><table><thead><tr><th>Annotation</th><th>Type</th><th>Description</th><th>chapter</th></tr></thead><tbody>
<tr><td><code>[T]</code></td><td>List</td><td>List of elements with type <code>T</code> each</td><td><a href="specification/list.html">List</a></td></tr>
<tr><td><code>{N::T}</code></td><td>AttrSet</td><td>AttrSet where member <code>N</code> references value of type <code>T</code></td><td><a href="specification/attrset.html">AttrSet</a></td></tr>
<tr><td><code>T-&gt;U</code></td><td>Lambda</td><td>A function that takes a single argument of type <code>T</code> and returns a value of type <code>U</code></td><td><a href="specification/lambda.html">lambda</a></td></tr>
</tbody></table>
</div>
<blockquote>
<p>More details how to use complex types in the corresponding chapters</p>
</blockquote>
<!-- markdownlint-disable MD041 -->
<!-- markdownlint-disable MD013 -->
<h3 id="composed"><a class="header" href="#composed">Composed</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Composition</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Number</code></td><td><code>Int {or} Float</code></td><td>The <code>Number</code> is either of type <code>Int</code> or of type <code>Float</code></td></tr>
<tr><td><code>Any</code></td><td><code>?</code></td><td>There is no <code>Any</code> type and it is explicitly prohibited to use the Any type. Use type variables instead if you want to allow variable type signatures.</td></tr>
<tr><td><code>StorePath</code></td><td><code>Path</code></td><td>The <code>StorePath</code> is just a meaningful alias of the type <code>Path</code></td></tr>
<tr><td><code>Derivation</code></td><td><code>{ ... }</code></td><td>TODO: <code>Derivation</code> is just a special AttrSet.</td></tr>
<tr><td><code>Package</code></td><td><code>Derivation {or} {...}</code></td><td>TODO: <code>Package</code> is either a Derivation or a special AttrSet with <code>name</code> xy in it.</td></tr>
</tbody></table>
</div>
<blockquote>
<p>used operators are defined in the <a href="specification/operators.html">operators chapter</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitives-1"><a class="header" href="#primitives-1">Primitives</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The following primitive types have been identified.</p>
<p>All other types can be composed from them by using those and the <a href="specification/./operators.html">operators</a>.</p>
<!-- markdownlint-disable MD041 -->
<h3 id="primitives-2"><a class="header" href="#primitives-2">Primitives</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Bool</td><td>A value of type boolean can be either <code>true</code> or <code>false</code></td></tr>
<tr><td>Int</td><td>TODO: The classical integer type with 32-bit or 64-bit depending on the current system?</td></tr>
<tr><td>Float</td><td>A float with 64 bits?</td></tr>
<tr><td>String</td><td>A string of any unicode characters</td></tr>
<tr><td>Path</td><td>Path referencing a location or a file. With no assumptions on the existence of that</td></tr>
<tr><td>Null</td><td>The value null</td></tr>
</tbody></table>
</div>
<h2 id="the-any-type-1"><a class="header" href="#the-any-type-1">The <code>Any</code> type</a></h2>
<p>The <code>Any</code> type is often used to explicitly allow arbitrary values. However,
the Any type is complex and doesn't add much value to a type system. Instead, we should use type variables whenever possible.</p>
<p>Interestingly there are two different <code>Any</code> types:</p>
<p>e.g. If we look at CUE-lang (which is also inspired by nix)</p>
<blockquote>
<p>CUE defines the values bottom, or error, (denoted <em>|</em>) that is an instance of all types and top, or any, (denoted _) of which all types are an instance.</p>
</blockquote>
<ul>
<li>
<p><code>TOP any</code> all types are an instance of that. You can imagine it as the TOP-most set, that includes every type. But no value has that type.</p>
</li>
<li>
<p><code>Bottom any</code> which is an instance of all types. This is kind of the imaginary value that has
the any type. Still, doesn't contain any value. Which could also be denoted: <code>Never</code> or <code>Empty Type</code> it is a type that is the subtype of any type.</p>
</li>
</ul>
<p>The following is a nice quote from the Typescript world</p>
<blockquote>
<p>The any type is so dangerous because it exists outside of the type tree.
It is both a top and bottom type.
Everything can be assigned to it and it can be assigned to everything else. ...</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="complex-1"><a class="header" href="#complex-1">Complex</a></h1>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>The following complex types have been identified.</p>
<p>All complex types can be composed from Any other types even from themselves by using those and the <a href="specification/./operators.html">operators</a>.</p>
<!-- markdownlint-disable MD041 -->
<h3 id="complex-2"><a class="header" href="#complex-2">Complex</a></h3>
<blockquote>
<p><code>T</code>, <code>U</code>, ...; are placeholders for any types, those MUST be specifically declared on usage</p>
</blockquote>
<hr />
<div class="table-wrapper"><table><thead><tr><th>Annotation</th><th>Type</th><th>Description</th><th>chapter</th></tr></thead><tbody>
<tr><td><code>[T]</code></td><td>List</td><td>List of elements with type <code>T</code> each</td><td><a href="specification/list.html">List</a></td></tr>
<tr><td><code>{N::T}</code></td><td>AttrSet</td><td>AttrSet where member <code>N</code> references value of type <code>T</code></td><td><a href="specification/attrset.html">AttrSet</a></td></tr>
<tr><td><code>T-&gt;U</code></td><td>Lambda</td><td>A function that takes a single argument of type <code>T</code> and returns a value of type <code>U</code></td><td><a href="specification/lambda.html">lambda</a></td></tr>
</tbody></table>
</div>
<blockquote>
<p>More details how to use complex types in the corresponding chapters</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="list"><a class="header" href="#list">List</a></h1>
<h2 id="abstract-definition"><a class="header" href="#abstract-definition">Abstract definition</a></h2>
<p>Let <code>[ a ]</code> be a list where the elements of that list do not have any type constraints.</p>
<p>Then a List of a specific Type <code>[ T ]</code> is a list where all elements <code>a</code> fullfil the type constraint <code>T</code></p>
<blockquote>
<p>A list <code>[]</code> can contain <strong>no</strong>, <strong>one</strong> or <strong>multiple</strong> elements. (0...n)</p>
<p>However the List-type can only contain one simple type expression.</p>
</blockquote>
<p>See syntax rules to learn what a simple type expression is.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="list-of-string"><a class="header" href="#list-of-string">list of string</a></h3>
<p><code>[ String ]</code></p>
<h3 id="list-of-string-or-bool"><a class="header" href="#list-of-string-or-bool">list of string or bool</a></h3>
<p><code>[ Number | Bool ]</code></p>
<p>-&gt; see the <code>|</code> {or} operator defined <a href="specification/./operators.html">here</a></p>
<h3 id="empty-list"><a class="header" href="#empty-list">empty list</a></h3>
<p><code>[ ]</code></p>
<h3 id="list-of-any-attrset"><a class="header" href="#list-of-any-attrset">list of any attrSet</a></h3>
<p><code>[ { ... } ]</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attrset"><a class="header" href="#attrset">AttrSet</a></h1>
<h2 id="abstract"><a class="header" href="#abstract">Abstract</a></h2>
<p>An <code>AttrSet</code> type can be thought of as just a list of <code>pair of name and value</code>.</p>
<ul>
<li><code>fst</code> on <code>pair of name and value</code> yields the <code>name</code>.</li>
<li><code>snd</code> on <code>pair of name and value</code> yields the <code>value</code>.</li>
</ul>
<p>Then <code>AttrSet</code> can be written as:</p>
<pre><code class="language-nix">[Pair(name,value)]
</code></pre>
<p>when you reference a specific <strong>name</strong> on an AttrSet; You basically implicitly apply a <code>filter</code> or <code>find</code> operation on that list where the <code>fst</code> of the <code>mapped entry</code> equals the referenced <strong>name</strong></p>
<p>For simplicity this is called a <code>member name</code> from now on, if that name exists.</p>
<p>If that name does not exist it is called <code>non-existing member name</code>.</p>
<h2 id="redefining-some-operators"><a class="header" href="#redefining-some-operators">Redefining some operators</a></h2>
<p><code>::</code>-operator within <code>AttrSet</code> contexts</p>
<p>The <code>::</code>-operator maps the Type of its <code>RHS</code> over the <code>Type</code> on its <code>LHS</code>. It can take an <code>Iterable</code> or a <code>single element</code> on its LHS.</p>
<p>Within Type-declarations for AttrSets it is possible to declare an explicit <code>member name</code> of an AttrSet like this.</p>
<pre><code class="language-nix">  {
    N :: T
  }
</code></pre>
<p>Then <code>N</code> is of type <code>String</code> and <code>N</code> becomes a <code>member name</code> of that AttrSet. The <code>snd</code> operation on the entry of <code>N</code> would yield a value of type <code>T</code>.</p>
<p>Introducing: <code>[ N :: T ]</code>-operator, which can only be used within <code>AttrSet</code> in <code>member name</code> fields.</p>
<p>The <code>[ N :: T ]</code>-operator maps over all <code>member names</code> of an AttrSet <code>[N]</code> and applies the type <code>T</code> to each member name <code>N</code> if not already done by explicit member__ declaration (see above).</p>
<p>When there are AttrSets with dynamic members it is possible to declare all those members at once with the <code>[ N :: T ]</code> and <code>::</code> operator.</p>
<p>Then an AttrSet with list of dynamic members where each member-name <code>N</code> references a <strong>value of type</strong> <code>V</code> can be written as.</p>
<pre><code class="language-nix">  { 
    [ N :: T ] :: V 
  }
</code></pre>
<h3 id="examples-1"><a class="header" href="#examples-1">Examples</a></h3>
<pre><code class="language-nix">  # member '.foo' references a value of type string
  # all other members `*` are of type string and each member reference value of any variable Type.
  { 
    [ name :: String ] :: a, 
    foo :: String 
  }
</code></pre>
<pre><code class="language-nix">  { foo :: a } 
</code></pre>
<pre><code class="language-nix">   {} 
</code></pre>
<p>where the member names `[ N :: T ] are an empty list.</p>
<h2 id="useful--shortcut"><a class="header" href="#useful--shortcut">useful <code>${}</code> Shortcut</a></h2>
<p><code>${N} = [ N :: String ]</code></p>
<p>If we take into account that in AttrSets <code>names</code> (<code>N</code>) are always of type <code>String</code> the user can omit the <code>String</code> Keyword completely, and instead give only the names. <code>N</code></p>
<p>That rule allows for intuitive usage of names within type definitions of an AttrSet</p>
<pre><code class="language-nix">/*
type:
  packageMap :: { 
    ${pname} :: {
      ${version} :: Derivation
    }
  }
*/
packageMap = {
  &quot;gcc-utils&quot; = {
    &quot;1.2.3&quot; = builtins.Derivation {...};
    };
  # ...
  };
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambda"><a class="header" href="#lambda">Lambda</a></h1>
<h2 id="abstract-definition-1"><a class="header" href="#abstract-definition-1">Abstract definition</a></h2>
<p>A lambda is a function that takes exactly one <code>argument</code> and returns exactly one <code>result</code>.</p>
<p>It is denoted as follows:</p>
<pre><code class="language-nix">a -&gt; b
</code></pre>
<p>Where <code>a</code> is the <code>argument</code> and <code>b</code> is the returned <code>result</code>.</p>
<p>Then a typed lambda notation:</p>
<pre><code class="language-nix">T -&gt; G
</code></pre>
<p>Denotes that <code>T</code> is the type of argument <code>a</code> and <code>G</code> is the type of result <code>b</code>.</p>
<blockquote>
<p>In <code>lambda</code> notations arguments do not have names like in e.g. <code>AttrSet</code> because they are positional arguments.</p>
</blockquote>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<h3 id="lambda-that-takes-a-string-and-returns-string"><a class="header" href="#lambda-that-takes-a-string-and-returns-string">Lambda that takes a <code>String</code> and returns <code>String</code></a></h3>
<p><code>String -&gt; String</code></p>
<h3 id="function-that-takes-string-and-number-and-finally-returns-string"><a class="header" href="#function-that-takes-string-and-number-and-finally-returns-string">Function that takes <code>String</code> and <code>Number</code> and finally returns <code>String</code></a></h3>
<p><code>String -&gt; Number -&gt; String</code></p>
<blockquote>
<p>As lambdas can take only one argument, the return type of the first lambda expression is a lambda that takes the second argument and returns the final type.</p>
</blockquote>
<h3 id="function-that-takes-a-function"><a class="header" href="#function-that-takes-a-function">Function that takes a function</a></h3>
<p><code>(String -&gt; String) -&gt; [String] -&gt; [String]</code></p>
<blockquote>
<p>Sometimes parenthesis is necessary to clarify order of evaluation</p>
<p>The <code>()</code> Parenthesis operator is defined <a href="specification/./operators.html">here</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operators"><a class="header" href="#operators">Operators</a></h1>
<p><strong>All Operators SHOULD be used with surrounding whitespace.</strong></p>
<h2 id="-declares-the-type"><a class="header" href="#-declares-the-type"><code>::</code> declares the type</a></h2>
<p>The variable name on the LHS is declared to have the <code>type</code> on the RHS</p>
<p>e.g. <code>name :: String</code></p>
<h2 id="-parenthesis"><a class="header" href="#-parenthesis"><code>()</code> Parenthesis</a></h2>
<p>Parenthesis to clarify order of type evaluation</p>
<p>e.g. <code>( a -&gt; b ) | Bool</code></p>
<p>Precedence: (Highest)</p>
<h2 id="-separator-for-subsequent-entries-like-in-attrset"><a class="header" href="#-separator-for-subsequent-entries-like-in-attrset"><code>;</code> Separator for subsequent entries (like in AttrSet)</a></h2>
<p>e.g. <code>{ foo :: Number; bar :: String }</code></p>
<blockquote>
<p>Important: This is a syntax rule!</p>
<p>Currently this is very inconsistent in nixpkgs.</p>
</blockquote>
<h2 id="-syntactic-or"><a class="header" href="#-syntactic-or"><code>|</code> syntactic or</a></h2>
<p>syntactic <code>Or</code> can be used for composition or enums</p>
<p>Let <code>T</code> and <code>U</code> be different Types.
Then the <code>|</code> operator evaluates to either <code>T</code> or <code>U</code>.</p>
<blockquote>
<p>Sometimes within this paper <code>|</code> is written as <code>{or}</code></p>
<p>This is only due to readability and not allowed in the real language</p>
</blockquote>
<p>Precedence: 2</p>
<h3 id="examples-3"><a class="header" href="#examples-3">Examples</a></h3>
<p><code>Float | Int</code></p>
<p><code>( Number | Bool ) | Int</code></p>
<p><code>{ opt :: Int | String }</code></p>
<pre><code class="language-nix"># lets say we want to create a type which can represent the type of both 'foo' and 'bar'
let
  /*
    Type:
      FooBar = Int | String

      foo :: FooBar
  */
  foo = 1;
  /*
    Type: 
      bar :: FooBar
  */
  bar = &quot;baz&quot;;

in
  # ....

</code></pre>
<h3 id="---arbitrary-input-values"><a class="header" href="#---arbitrary-input-values"><code>...</code> - arbitrary input values</a></h3>
<p>can only be used within an AttrSet to allow <code>Any</code> more <code>name-value pairs</code>.</p>
<p><code>...</code> = <code>${rest} :: a</code> within an AttrSet context</p>
<p>e.g.</p>
<pre><code class="language-nix">/*
  Type: foo :: { bar :: a, ...} -&gt; a
*/
Foo = {bar, ...}@inp:
#...
</code></pre>
<p>Precedence: None</p>
<h2 id="-merge-operator"><a class="header" href="#-merge-operator"><code>//</code> merge operator</a></h2>
<p>syntactically <code>merges</code> Types of AttrSets</p>
<p><code>{ foo :: String } // { bar :: Number }</code> =&gt; <code>{ foo :: String; bar :: Number }</code></p>
<p><code>{ foo :: String } // { ${names} :: a }</code> =&gt; <code>{ foo :: String; ${names} :: a  }</code></p>
<p>Overwrites occur like in the nix language itself</p>
<p><code>{ foo :: String } // { foo :: Number }</code> =&gt; <code>{ foo :: Number }</code></p>
<p>Precedence: 3</p>
<h2 id="--arrow-operator"><a class="header" href="#--arrow-operator"><code>-&gt;</code> arrow operator</a></h2>
<p>Allows for lambda types</p>
<p>Precedence: 1</p>
<h2 id="-optional-arguments-in-an-attrset"><a class="header" href="#-optional-arguments-in-an-attrset"><code>?</code> optional arguments in an AttrSet</a></h2>
<p>--e.g.  <code>{ opt :: Int ? }</code></p>
<p>Note: The <strong>very end</strong> of <code>type</code> side contains the <code>?</code> operator.</p>
<p>The reason for this is <strong>extendability</strong>. Initially the <code>?</code>-Operator is introduced as Unary-operator, marking the entry type as optional.
In future it will be desirable to use the <code>?</code> as binary-operator to add default values on optional entries.</p>
<p>e.g.</p>
<pre><code class="language-nix">{
  foo :: Int ? 1;
}
</code></pre>
<p>Precedence: None</p>
<h2 id="precedence"><a class="header" href="#precedence">Precedence</a></h2>
<p>Precedence is just taken from the official nix operators.
To make usage as intuitive as possible.
However the type language only uses a tight subset of the operator available in nix.</p>
<p>-&gt; see <a href="specification/./grammar.html">grammar</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-variables"><a class="header" href="#type-variables">Type Variables</a></h1>
<h2 id="abstract-1"><a class="header" href="#abstract-1">Abstract</a></h2>
<p>As the explicit <code>Any</code> keyword is prohibited. Even there is no such <code>Any</code> type.</p>
<p>It is of course possible to construct the <code>Any</code> type and use it properly but in good type systems there is no need for that type.</p>
<p>The <code>Any</code> type is covered from <code>Polymorphism</code> with the usage of <code>type variables</code>.</p>
<p>Type variables can have any name but it is usually considered best practice to choose either letters from the latin alphabet or use meaningful names.</p>
<blockquote>
<p><code>Type variables</code> must be written in LOWERCASE to prevent confusion.</p>
</blockquote>
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<p>The following function signatures from <code>nix</code> and <code>nixpkgs</code> are written most clearly with <code>type variables</code></p>
<h3 id="builtinsmap"><a class="header" href="#builtinsmap">builtins.map</a></h3>
<pre><code class="language-nix">( a -&gt; b ) -&gt; [a] -&gt; [b]
</code></pre>
<h3 id="builtinscatattrs"><a class="header" href="#builtinscatattrs">builtins.catAttrs</a></h3>
<pre><code class="language-nix">String -&gt; [ { ${name} :: a } ] -&gt; [a]
</code></pre>
<h3 id="libattrsetsattrbypath"><a class="header" href="#libattrsetsattrbypath">lib.attrsets.attrByPath</a></h3>
<pre><code class="language-nix">[ String ] -&gt; a -&gt; { ${path} :: b } -&gt; (a | b)
</code></pre>
<h3 id="builtinsmapattrs"><a class="header" href="#builtinsmapattrs">builtins.mapAttrs</a></h3>
<pre><code class="language-nix">(String -&gt; a -&gt; b) -&gt; { ${name} :: a } -&gt; { ${name} :: b }
</code></pre>
<h3 id="builtinssort"><a class="header" href="#builtinssort">builtins.sort</a></h3>
<pre><code class="language-nix">(a -&gt; a -&gt; Bool) -&gt; [a] -&gt; [a]
</code></pre>
<h2 id="namespaces"><a class="header" href="#namespaces">Namespaces</a></h2>
<p>Type variables are currently the best way to properly use polymorphism in type signatures.
But using them requires the underlying parser and the user need to understand some concepts like namespaces and shadowing.</p>
<p>This section orients itself on the <em>Haskell type variables</em>. See here for <a href="https://downloads.haskell.org/ghc/latest/docs/users_guide/exts/scoped_type_variables.html">their rules</a></p>
<blockquote>
<p>In nix we don't have the same syntax as haskell has but the basic principles and core concept will be adopted from the parser.</p>
</blockquote>
<h3 id="bigger-sets-with-nested-type-variables"><a class="header" href="#bigger-sets-with-nested-type-variables">Bigger sets with nested type variables</a></h3>
<p>sometime it is possible to have expressions, that contain multiple levels of nestings, where also different hierarchies of <code>type variables</code> must interact with each other.</p>
<pre><code class="language-nix">{ foo :: a } -&gt; {
  nestedFunction :: a -&gt; b,
  bar :: ( b -&gt; c ) -&gt; [c] -&gt; [b]
}
</code></pre>
<p>This seem a little complex now, because the parent function returns an AttrSet that includes function signatures using the same <code>type variables</code> as the outermost function itself.</p>
<blockquote>
<p><strong>There is actually a very strict and proven ruleset for that exact problem out there.</strong></p>
<p>The Haskell Ruleset for <a href="https://downloads.haskell.org/ghc/latest/docs/users_guide/exts/scoped_type_variables.html">scoped type variables</a></p>
<p>(see also above).</p>
</blockquote>
<h2 id="type-variables-with-constraints"><a class="header" href="#type-variables-with-constraints">Type Variables with constraints</a></h2>
<p>Sometime we have variable types in signatures, but cannot allow any type for the variable.
Then we could construct a type and assign it like this.</p>
<pre><code class="language-nix">  Foo = ( String | Path )
  Foo -&gt; Foo 
</code></pre>
<blockquote>
<p>This is already allowed syntax in the proposed type system. There are no additional changes that need to be made.</p>
<p>Sometimes there might be more than one expression necessary to express the type of a function.</p>
</blockquote>
<p>Also this means that the annotated function might take a <code>String</code> or a <code>Path</code>, and also returns them.
If that function takes a <code>String</code> it will return the same <code>String</code> type. Once <code>Foo</code> evaluates to type <code>String</code> every occurrence of <code>Foo</code> is then of type <code>String</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nix"><a class="header" href="#nix">Nix</a></h1>
<h2 id="the-language-fundamentals"><a class="header" href="#the-language-fundamentals">The language fundamentals</a></h2>
<p>It is very desireable to build a solid set of type signatures for the most basic operators in <code>nix</code>.</p>
<p>Those are:</p>
<ul>
<li>language syntax</li>
<li><a href="nix/./operations.html">Operations</a></li>
<li><a href="nix/./builtins.html">Builtins</a></li>
</ul>
<blockquote>
<p>If those basic functionality from a type perspective of the language itself is clarified.</p>
<p>this opens a whole new spectrum of possibilities like <strong>type inference</strong> or <strong>type checking</strong>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operations"><a class="header" href="#operations">Operations</a></h1>
<p>The official documentation about the operators in nix can be found <a href="https://nixos.org/manual/nix/stable/language/operators.html">here</a></p>
<p>🚧🚧🚧 This site is WIP</p>
<h2 id="official-list"><a class="header" href="#official-list">Official List</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Syntax</th><th>Associativity</th><th>Precedence</th></tr></thead><tbody>
<tr><td>Attribute selection</td><td><em>AttrSet</em> <code>.</code> <em>AttrPath</em> [ <code>or</code> <em>expr</em> ]</td><td>none</td><td>1</td></tr>
<tr><td>Function application</td><td><em>func</em> <em>expr</em></td><td>left</td><td>2</td></tr>
<tr><td>Arithmetic negation</td><td><code>-</code> <em>number</em></td><td>none</td><td>3</td></tr>
<tr><td>Has attribute</td><td><em>AttrSet</em> <code>?</code> <em>AttrPath</em></td><td>none</td><td>4</td></tr>
<tr><td>ist concatenation</td><td><em>list</em> <code>++</code> <em>list</em></td><td>right</td><td>5</td></tr>
<tr><td>Multiplication</td><td><em>number</em> <code>*</code> <em>number</em></td><td>left</td><td>6</td></tr>
<tr><td>Division</td><td><em>number</em> <code>/</code> <em>number</em></td><td>left</td><td>6</td></tr>
<tr><td>Subtraction</td><td><em>number</em> <code>-</code> <em>number</em></td><td>left</td><td>7</td></tr>
<tr><td>Addition</td><td><em>number</em> <code>+</code> <em>number</em></td><td>left</td><td>7</td></tr>
<tr><td>String concatenation</td><td><em>string</em> <code>+</code> <em>string</em></td><td>left</td><td>7</td></tr>
<tr><td>Path concatenation</td><td><em>path</em> <code>+</code> <em>path</em></td><td>left</td><td>7</td></tr>
<tr><td>Path and string concatenation</td><td><em>path</em> <code>+</code> <em>string</em></td><td>left</td><td>7</td></tr>
<tr><td>String and path concatenation</td><td><em>string</em> <code>+</code> <em>path</em></td><td>left</td><td>7</td></tr>
<tr><td>Logical negation (<code>NOT</code>)</td><td><code>!</code> <em>bool</em></td><td>none</td><td>8</td></tr>
<tr><td>Update</td><td><em>AttrSet</em> <code>//</code> <em>AttrSet</em></td><td>right</td><td>9</td></tr>
<tr><td>Less than</td><td><em>expr</em> <code>&lt;</code> <em>expr</em></td><td>none</td><td>10</td></tr>
<tr><td>Less than or equal to</td><td><em>expr</em> <code>&lt;=</code> <em>expr</em></td><td>none</td><td>10</td></tr>
<tr><td>Greater than</td><td><em>expr</em> <code>&gt;</code> <em>expr</em></td><td>none</td><td>10</td></tr>
<tr><td>Greater than or equal to</td><td><em>expr</em> <code>&gt;=</code> <em>expr</em></td><td>none</td><td>10</td></tr>
<tr><td>Equality</td><td><em>expr</em> <code>==</code> <em>expr</em></td><td>none</td><td>11</td></tr>
<tr><td>Inequality</td><td><em>expr</em> <code>!=</code> <em>expr</em></td><td>none</td><td>11</td></tr>
<tr><td>Logical conjunction (<code>AND</code>)</td><td><em>bool</em> <code>&amp;&amp;</code> <em>bool</em></td><td>left</td><td>12</td></tr>
<tr><td>Logical disjunction (<code>OR</code>)</td><td><em>bool</em> <code>\|\|</code> <em>bool</em></td><td>left</td><td>13</td></tr>
<tr><td>Logical implication</td><td><em>bool</em> <code>-&gt;</code> <em>bool</em></td><td>none</td><td>14</td></tr>
</tbody></table>
</div>
<h2 id="type-signatures"><a class="header" href="#type-signatures">Type signatures</a></h2>
<p>From a type perspective those operators can be seen as lambda functions. Every operator takes arguments of one type and returns a type.
The following list was created to clarify the type signatures.</p>
<p>Some operators take one or two arguments, they can either take them from left or right hand side.</p>
<h3 id="some-formals"><a class="header" href="#some-formals">Some formals</a></h3>
<p>for simplicity</p>
<ul>
<li><code>R</code> is used as <code>Right hand side</code> type.</li>
<li><code>L</code> is used as <code>Left hand side</code> type.</li>
<li>When using the proposed lambda notation, the first argument is always <code>LHS</code> and the second the <code>RHS</code> of the discussed operator.</li>
<li><code>T,U,W</code> are used as generic Type variables mostly do denote the resulting type, or types of free variables.</li>
<li><code>a</code>,<code>b</code>,... can be of any type. They are type variables.</li>
<li><code>x</code> is a functions input value</li>
<li><code>y</code> is a functions return value</li>
</ul>
<h3 id="---attribute-selection"><a class="header" href="#---attribute-selection">'.' - Attribute selection</a></h3>
<p>Usage of the (<code>.</code>) operator:</p>
<p><code>L</code> must be an AttrSet, and <code>R</code> must evaluate to type <code>String</code></p>
<p>If R itself contains an expression this is parenthesized with the <code>${ }</code> operator.
This operator tells the parser to evaluate the expression in <code>R</code> before passing it to the (<code>.</code>) function.</p>
<pre><code class="language-nix"> L(.)R = L.R 
</code></pre>
<pre><code class="language-nix"> L(.)R = L -&gt; R -&gt; T
 L(.)R :: { ${name} :: a } -&gt; String -&gt; a
</code></pre>
<h3 id="function-application"><a class="header" href="#function-application">Function application</a></h3>
<p>Let <code>f</code> be a function; <code>x</code> its applied argument and <code>y</code> the applied function result.</p>
<pre><code class="language-nix"> y = f x
</code></pre>
<p>For comprehensiveness let the type signature of the above function be <code>L</code> and the applied argument <code>R</code>.</p>
<p>blow the argument <code>R</code> is applied to a function of type <code>L</code>.</p>
<pre><code class="language-nix"> L R = L -&gt; R -&gt; T
 L R :: (a -&gt; b) -&gt; a -&gt; b 
</code></pre>
<h3 id="----minus-operator"><a class="header" href="#----minus-operator">'-' - minus operator</a></h3>
<pre><code class="language-nix"> y = x - 1
</code></pre>
<blockquote>
<p>(<code>-</code>) is a special case where the <code>RHS</code> is applied first to the function.
So if the <code>LHS</code> was omitted it gets the value <code>0</code> as type <code>Int</code>.</p>
</blockquote>
<pre><code class="language-nix"> L(-)R :: R -&gt; L -&gt; T
 (-) :: ( Int | Float ) -&gt; ( Int | Float | 0 ) -&gt; (Int | Float)
</code></pre>
<p>The minus operator is a dependent type
It depends on the received argument value</p>
<ul>
<li>If it receives two <code>Int</code> types it returns <code>Int</code></li>
<li>but if one or both of its arguments is of type <code>Float</code> it returns type <code>Float</code></li>
<li>The type signature is correct using the <code>Number</code> type, but it lacks the information about its <code>value dependency</code>.</li>
</ul>
<h3 id="---plus-operator"><a class="header" href="#---plus-operator">'+' - plus operator</a></h3>
<h3 id="---has-attribute"><a class="header" href="#---has-attribute">'?' - Has attribute</a></h3>
<h3 id="---list-concatenation"><a class="header" href="#---list-concatenation">'++' - List concatenation</a></h3>
<h3 id="----comparison"><a class="header" href="#----comparison">'&lt;' '&gt;' - comparison</a></h3>
<h3 id="---equality"><a class="header" href="#---equality">'==' - Equality</a></h3>
<h3 id="---inequality"><a class="header" href="#---inequality">'!=' - Inequality</a></h3>
<h3 id="---multiplication"><a class="header" href="#---multiplication">'*' - Multiplication</a></h3>
<h3 id="---negation"><a class="header" href="#---negation">'!' - Negation</a></h3>
<h3 id="---update"><a class="header" href="#---update">'//' - Update</a></h3>
<h3 id="------logical"><a class="header" href="#------logical">'&amp;&amp;' '||' '-&gt;' - Logical</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="builtins"><a class="header" href="#builtins">Builtins</a></h1>
<p>This section contains the proof that all nix <code>builtins</code> can be meaningfully and correctly annotated with the proposed type system.</p>
<p>There are currently <strong>89</strong> builtin functions, that can be discovered with</p>
<blockquote>
<p>run <code>nix __dump-builtins</code></p>
</blockquote>
<p>Every builtins signature can be found below (sorted alphabetically)</p>
<blockquote>
<p>Following symbols are used below</p>
<ul>
<li>✅ - Compliant</li>
<li>⚠️ - Under construction.</li>
</ul>
</blockquote>
<h2 id="builtins---todo-the-type-signatures-are-not-compliant-yet"><a class="header" href="#builtins---todo-the-type-signatures-are-not-compliant-yet">Builtins - TODO: The type signatures are not compliant yet</a></h2>
<!-- markdownlint-disable MD041 -->
<!-- markdownlint-disable MD013 -->
<h3 id="abort-"><a class="header" href="#abort-">abort ⚠️</a></h3>
<pre><code class="language-nix">String -&gt; Error
</code></pre>
<h3 id="add-"><a class="header" href="#add-">add ✅</a></h3>
<pre><code class="language-nix">Number -&gt; Number -&gt; Number
</code></pre>
<h3 id="all-"><a class="header" href="#all-">all ✅</a></h3>
<pre><code class="language-nix">(a -&gt; Bool) -&gt; [a] -&gt; Bool
</code></pre>
<h3 id="any-"><a class="header" href="#any-">any ✅</a></h3>
<pre><code class="language-nix">(a -&gt; Bool) -&gt; [a] -&gt; Bool
</code></pre>
<h3 id="attrnames-"><a class="header" href="#attrnames-">attrNames ✅</a></h3>
<pre><code class="language-nix">{ ${key} :: a } -&gt; [String]
</code></pre>
<h3 id="attrvalues-"><a class="header" href="#attrvalues-">attrValues ✅</a></h3>
<pre><code class="language-nix">{ ${key} :: a } -&gt; [a]
</code></pre>
<h3 id="basenameof-"><a class="header" href="#basenameof-">baseNameOf ✅</a></h3>
<pre><code class="language-nix">( String | Path ) -&gt; String
</code></pre>
<h3 id="bitand-"><a class="header" href="#bitand-">bitAnd ✅</a></h3>
<pre><code class="language-nix">Int -&gt; Int -&gt; Int
</code></pre>
<h3 id="bitor-"><a class="header" href="#bitor-">bitOr ✅</a></h3>
<pre><code class="language-nix">Int -&gt; Int -&gt; Int
</code></pre>
<h3 id="bitxor-"><a class="header" href="#bitxor-">bitXor ✅</a></h3>
<pre><code class="language-nix">Int -&gt; Int -&gt; Int
</code></pre>
<h3 id="break-"><a class="header" href="#break-">break ✅</a></h3>
<pre><code class="language-nix">a -&gt; a
</code></pre>
<h3 id="catattrs-"><a class="header" href="#catattrs-">catAttrs ✅</a></h3>
<pre><code class="language-nix">String -&gt; [ { ${name} :: a } ] -&gt; [a]
</code></pre>
<h3 id="ceil-"><a class="header" href="#ceil-">ceil ✅</a></h3>
<pre><code class="language-nix">Number -&gt; Int
</code></pre>
<h3 id="compareversions-"><a class="header" href="#compareversions-">compareVersions ✅</a></h3>
<pre><code class="language-nix">String -&gt; String -&gt; (-1 | 0 | 1)
</code></pre>
<h3 id="concatlists-"><a class="header" href="#concatlists-">concatLists ✅</a></h3>
<pre><code class="language-nix">[ [ a ] ] -&gt; [ a ]
</code></pre>
<h3 id="concatmap-"><a class="header" href="#concatmap-">concatMap ✅</a></h3>
<pre><code class="language-nix">( a -&gt; [ b ] ) -&gt; [ a ] -&gt; [ b ]
</code></pre>
<h3 id="concatstringssep-"><a class="header" href="#concatstringssep-">concatStringsSep ✅</a></h3>
<pre><code class="language-nix">String -&gt; [ ( String | Path ) ] -&gt; String
</code></pre>
<h3 id="deepseq-"><a class="header" href="#deepseq-">deepSeq ✅</a></h3>
<pre><code class="language-nix">a -&gt; b -&gt; b
</code></pre>
<h3 id="dirof-"><a class="header" href="#dirof-">dirOf ✅</a></h3>
<pre><code class="language-nix">a = (Path | String)
a -&gt; a
</code></pre>
<h3 id="div-"><a class="header" href="#div-">div ⚠️</a></h3>
<pre><code class="language-nix">Number -&gt; Number -&gt; Number
</code></pre>
<h3 id="elem-"><a class="header" href="#elem-">elem ⚠️</a></h3>
<pre><code class="language-nix">a -&gt; [b] -&gt; Bool
</code></pre>
<h3 id="elemat-"><a class="header" href="#elemat-">elemAt ⚠️</a></h3>
<pre><code class="language-nix">[a] -&gt; Int -&gt; b
</code></pre>
<h3 id="fetchclosure-"><a class="header" href="#fetchclosure-">fetchClosure ⚠️</a></h3>
<pre><code class="language-nix">AttrSet -&gt; AttrSet
</code></pre>
<h3 id="fetchgit-"><a class="header" href="#fetchgit-">fetchGit ⚠️</a></h3>
<pre><code class="language-nix">AttrSet -&gt; AttrSet
</code></pre>
<h3 id="fetchtarball-"><a class="header" href="#fetchtarball-">fetchTarball ⚠️</a></h3>
<pre><code class="language-nix">AttrSet -&gt; AttrSet
</code></pre>
<h3 id="fetchurl-"><a class="header" href="#fetchurl-">fetchurl ⚠️</a></h3>
<pre><code class="language-nix">String -&gt; AttrSet
</code></pre>
<h3 id="filter-"><a class="header" href="#filter-">filter ⚠️</a></h3>
<pre><code class="language-nix">(a -&gt; Bool) -&gt; [a] -&gt; [b]
</code></pre>
<h3 id="filtersource-"><a class="header" href="#filtersource-">filterSource ⚠️</a></h3>
<pre><code class="language-nix">(Path -&gt; String -&gt; Bool) -&gt; Path -&gt; Path
</code></pre>
<h3 id="floor-"><a class="header" href="#floor-">floor ⚠️</a></h3>
<pre><code class="language-nix">Float -&gt; Int
</code></pre>
<h3 id="foldl-"><a class="header" href="#foldl-">foldl' ⚠️</a></h3>
<pre><code class="language-nix">(a -&gt; b -&gt; c) -&gt; a -&gt; [b] -&gt; c
</code></pre>
<h3 id="fromjson-"><a class="header" href="#fromjson-">fromJSON ⚠️</a></h3>
<pre><code class="language-nix">String -&gt; a
</code></pre>
<h3 id="functionargs-"><a class="header" href="#functionargs-">functionArgs ⚠️</a></h3>
<pre><code class="language-nix">(a) -&gt; AttrSet
</code></pre>
<h3 id="genlist-"><a class="header" href="#genlist-">genList ⚠️</a></h3>
<pre><code class="language-nix">(a -&gt; b) -&gt; a -&gt; [b]
</code></pre>
<h3 id="genericclosure-"><a class="header" href="#genericclosure-">genericClosure ⚠️</a></h3>
<pre><code class="language-nix">AttrSet -&gt; [AttrSet]
</code></pre>
<h3 id="getattr-"><a class="header" href="#getattr-">getAttr ⚠️</a></h3>
<pre><code class="language-nix">String -&gt; AttrSet -&gt; a
</code></pre>
<h3 id="getenv-"><a class="header" href="#getenv-">getEnv ⚠️</a></h3>
<pre><code class="language-nix">String -&gt; String
</code></pre>
<h3 id="getflake-"><a class="header" href="#getflake-">getFlake ⚠️</a></h3>
<pre><code class="language-nix">AttrSet -&gt; AttrSet
</code></pre>
<h3 id="groupby-"><a class="header" href="#groupby-">groupBy ⚠️</a></h3>
<pre><code class="language-nix">(a -&gt; b) -&gt; [a] -&gt; AttrSet
</code></pre>
<h3 id="hasattr-"><a class="header" href="#hasattr-">hasAttr ⚠️</a></h3>
<pre><code class="language-nix">String -&gt; AttrSet -&gt; Bool
</code></pre>
<h3 id="hashfile-"><a class="header" href="#hashfile-">hashFile ⚠️</a></h3>
<pre><code class="language-nix">String -&gt; Path -&gt; String
</code></pre>
<h3 id="hashstring-"><a class="header" href="#hashstring-">hashString ⚠️</a></h3>
<pre><code class="language-nix">String -&gt; String -&gt; String
</code></pre>
<h3 id="head-"><a class="header" href="#head-">head ⚠️</a></h3>
<pre><code class="language-nix">[a] -&gt; a
</code></pre>
<h3 id="import-"><a class="header" href="#import-">import ⚠️</a></h3>
<pre><code class="language-nix">Path -&gt; a
</code></pre>
<h3 id="intersectattrs-"><a class="header" href="#intersectattrs-">intersectAttrs ⚠️</a></h3>
<pre><code class="language-nix">AttrSet -&gt; AttrSet -&gt; AttrSet
</code></pre>
<h3 id="isattrs-"><a class="header" href="#isattrs-">isAttrs ⚠️</a></h3>
<pre><code class="language-nix">a -&gt; Bool
</code></pre>
<h3 id="isbool-"><a class="header" href="#isbool-">isBool ⚠️</a></h3>
<pre><code class="language-nix">a -&gt; Bool
</code></pre>
<h3 id="isfloat-"><a class="header" href="#isfloat-">isFloat ⚠️</a></h3>
<pre><code class="language-nix">a -&gt; Bool
</code></pre>
<h3 id="isfunction-"><a class="header" href="#isfunction-">isFunction ⚠️</a></h3>
<pre><code class="language-nix">a -&gt; Bool
</code></pre>
<h3 id="isint-"><a class="header" href="#isint-">isInt ⚠️</a></h3>
<pre><code class="language-nix">a -&gt; Bool
</code></pre>
<h3 id="islist-"><a class="header" href="#islist-">isList ⚠️</a></h3>
<pre><code class="language-nix">a -&gt; Bool
</code></pre>
<h3 id="isnull-"><a class="header" href="#isnull-">isNull ⚠️</a></h3>
<pre><code class="language-nix">a -&gt; Bool
</code></pre>
<h3 id="ispath-"><a class="header" href="#ispath-">isPath ⚠️</a></h3>
<pre><code class="language-nix">a -&gt; Bool
</code></pre>
<h3 id="isstring-"><a class="header" href="#isstring-">isString ⚠️</a></h3>
<pre><code class="language-nix">a -&gt; Bool
</code></pre>
<h3 id="length-"><a class="header" href="#length-">length ⚠️</a></h3>
<pre><code class="language-nix">[a] -&gt; Int
</code></pre>
<h3 id="lessthan-"><a class="header" href="#lessthan-">lessThan ⚠️</a></h3>
<pre><code class="language-nix">Number -&gt; Number -&gt; Bool
</code></pre>
<h3 id="listtoattrs-"><a class="header" href="#listtoattrs-">listToAttrs ⚠️</a></h3>
<pre><code class="language-nix">[{name :: String, value :: a}] -&gt; AttrSet
</code></pre>
<h3 id="map-"><a class="header" href="#map-">map ⚠️</a></h3>
<pre><code class="language-nix">(a -&gt; b) -&gt; [a] -&gt; [b]
</code></pre>
<h3 id="mapattrs-"><a class="header" href="#mapattrs-">mapAttrs ⚠️</a></h3>
<pre><code class="language-nix">(a -&gt; b -&gt; c) -&gt; AttrSet -&gt; AttrSet
</code></pre>
<h3 id="match-"><a class="header" href="#match-">match ⚠️</a></h3>
<pre><code class="language-nix">String -&gt; String -&gt; ( Null | [ String ] )
</code></pre>
<h3 id="mul-"><a class="header" href="#mul-">mul ⚠️</a></h3>
<pre><code class="language-nix">Number -&gt; Number -&gt; Number
</code></pre>
<h3 id="parsedrvname-"><a class="header" href="#parsedrvname-">parseDrvName ⚠️</a></h3>
<pre><code class="language-nix">String -&gt; AttrSet
</code></pre>
<h3 id="partition-"><a class="header" href="#partition-">partition ⚠️</a></h3>
<pre><code class="language-nix">(a -&gt; Bool) -&gt; [a] -&gt; AttrSet
</code></pre>
<h3 id="path-"><a class="header" href="#path-">Path ⚠️</a></h3>
<pre><code class="language-nix">AttrSet -&gt; StorePath
</code></pre>
<h3 id="pathexists-"><a class="header" href="#pathexists-">pathExists ⚠️</a></h3>
<pre><code class="language-nix">Path -&gt; Bool
</code></pre>
<h3 id="placeholder-"><a class="header" href="#placeholder-">placeholder ⚠️</a></h3>
<pre><code class="language-nix">String -&gt; String
</code></pre>
<h3 id="readdir-"><a class="header" href="#readdir-">readDir ⚠️</a></h3>
<pre><code class="language-nix">Path -&gt; AttrSet
</code></pre>
<h3 id="readfile-"><a class="header" href="#readfile-">readFile ⚠️</a></h3>
<pre><code class="language-nix">Path -&gt; String
</code></pre>
<h3 id="removeattrs-"><a class="header" href="#removeattrs-">removeAttrs ⚠️</a></h3>
<pre><code class="language-nix">AttrSet -&gt; [a] -&gt; AttrSet
</code></pre>
<h3 id="replacestrings-"><a class="header" href="#replacestrings-">replaceStrings ⚠️</a></h3>
<pre><code class="language-nix">[String] -&gt; [String] -&gt; String -&gt; String
</code></pre>
<h3 id="seq-"><a class="header" href="#seq-">seq ✅</a></h3>
<pre><code class="language-nix">a -&gt; b -&gt; b
</code></pre>
<h3 id="sort-"><a class="header" href="#sort-">sort ✅</a></h3>
<pre><code class="language-nix">(a -&gt; a -&gt; Bool) -&gt; [a] -&gt; [a]
</code></pre>
<h3 id="split-"><a class="header" href="#split-">split ⚠️</a></h3>
<pre><code class="language-nix">String -&gt; String -&gt; [String]
</code></pre>
<h3 id="splitversion-"><a class="header" href="#splitversion-">splitVersion ⚠️</a></h3>
<pre><code class="language-nix">String -&gt; [String]
</code></pre>
<h3 id="storepath-"><a class="header" href="#storepath-">StorePath ⚠️</a></h3>
<pre><code class="language-nix">StorePath -&gt; StorePath
</code></pre>
<h3 id="stringlength-"><a class="header" href="#stringlength-">stringLength ⚠️</a></h3>
<pre><code class="language-nix">String -&gt; Int
</code></pre>
<h3 id="sub-"><a class="header" href="#sub-">sub ⚠️</a></h3>
<pre><code class="language-nix">Number -&gt; Number -&gt; Number
</code></pre>
<h3 id="substring-"><a class="header" href="#substring-">substring ⚠️</a></h3>
<pre><code class="language-nix">Int -&gt; Int -&gt; String -&gt; String
</code></pre>
<h3 id="tail-"><a class="header" href="#tail-">tail ⚠️</a></h3>
<pre><code class="language-nix">[a] -&gt; a
</code></pre>
<h3 id="throw-"><a class="header" href="#throw-">throw ⚠️</a></h3>
<pre><code class="language-nix">String
</code></pre>
<h3 id="tofile-"><a class="header" href="#tofile-">toFile ⚠️</a></h3>
<pre><code class="language-nix">Path -&gt; String -&gt; StorePath 
</code></pre>
<h3 id="tojson-"><a class="header" href="#tojson-">toJSON ⚠️</a></h3>
<pre><code class="language-nix">a -&gt; String
</code></pre>
<h3 id="topath-"><a class="header" href="#topath-">toPath ⚠️</a></h3>
<pre><code class="language-nix">String -&gt; Path
</code></pre>
<h3 id="tostring-"><a class="header" href="#tostring-">toString ⚠️</a></h3>
<pre><code class="language-nix">a -&gt; String
</code></pre>
<h3 id="toxml-"><a class="header" href="#toxml-">toXML ⚠️</a></h3>
<pre><code class="language-nix">a -&gt; String
</code></pre>
<h3 id="trace-"><a class="header" href="#trace-">trace ⚠️</a></h3>
<pre><code class="language-nix">a -&gt; b -&gt; b
</code></pre>
<h3 id="traceverbose-"><a class="header" href="#traceverbose-">traceVerbose ⚠️</a></h3>
<pre><code class="language-nix">a -&gt; b -&gt; b
</code></pre>
<h3 id="tryeval-"><a class="header" href="#tryeval-">tryEval ⚠️</a></h3>
<pre><code class="language-nix">a -&gt; a
</code></pre>
<h3 id="typeof-"><a class="header" href="#typeof-">typeOf ✅</a></h3>
<pre><code class="language-nix">a -&gt; &quot;bool&quot; | &quot;int&quot; | &quot;float&quot; | &quot;string&quot; | &quot;set&quot; | &quot;list&quot; | &quot;path&quot; | &quot;null&quot; | &quot;lambda&quot; 
</code></pre>
<h3 id="zipattrswith-"><a class="header" href="#zipattrswith-">zipAttrsWith ⚠️</a></h3>
<pre><code class="language-nix">(String -&gt; [a] ) -&gt; [a] -&gt; AttrSet
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage"><a class="header" href="#usage">Usage</a></h1>
<p>The goal was to create a system that can add <code>type hints</code> to every expression in nix.</p>
<p>A nix file can contain many possible things.</p>
<p>So what kind of expressions and formats does the <code>RFC</code> need to support?</p>
<ul>
<li>named function expression.</li>
<li>anonymous functions.</li>
<li>named variables.</li>
</ul>
<p>In any possible way nix has only expressions thus if this project covers all kind of expressions, it covers the complete nix language.</p>
<p>The following can be imported as a function called <code>foo</code> as the parent folder is named <code>foo</code> and contains a <code>default.nix</code></p>
<pre><code class="language-nix"># /foo/default.nix

{lib, ...}:
let
    applyIt = fn: fn 10;
#....
in
    act: applyIt act
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-cases"><a class="header" href="#use-cases">Use-cases</a></h1>
<h2 id="standardized-parsable-format-to-communicate-type"><a class="header" href="#standardized-parsable-format-to-communicate-type">Standardized (parsable) format to communicate type</a></h2>
<p>There are simple functions with only few and basic arguments.</p>
<pre><code class="language-nix">Number -&gt; Number -&gt; Number
</code></pre>
<p>But there are also complex functions, that other functions or nested attrsets as arguments.
Communicate the rules those structures may have to follow is crucial.</p>
<pre><code class="language-nix">String -&gt; [ { ${name} :: a } ] -&gt; [a]
</code></pre>
<p>We think; Understanding those <code>type</code> signatures with automated tooling is significant.
For that to work we need a syntax that follows strict rules.</p>
<h2 id="provide-hover-and-autocomplete-informations-on-expressions"><a class="header" href="#provide-hover-and-autocomplete-informations-on-expressions">Provide hover and autocomplete information's on expressions</a></h2>
<p>As a developer i'd like to get suggestions like:</p>
<ul>
<li>How many arguments does a certain function take?</li>
<li>Type of the arguments?</li>
<li>In case of Attribute-set arguments:
<ul>
<li>Which attributes of the required attributes are still missing?</li>
<li>Which optional attributes can i specify additionally?</li>
</ul>
</li>
<li>In general describe the type of an expression</li>
</ul>
<h2 id="provide-static-type-checks-at-development-time"><a class="header" href="#provide-static-type-checks-at-development-time">Provide static type checks at development time</a></h2>
<p>A static tool could check the actual type of the documented expression against the specified type.
It is unclear how this would work, but it could certainly be done.</p>
<p>We think an approach would also include pre-evaluation of certain points, that are very hard to analyze statically.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributors"><a class="header" href="#contributors">Contributors</a></h1>
<p>Thanks to all people who contributed to this project. (if agreed) github handles will be published here.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
